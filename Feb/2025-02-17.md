# OSI 7계층

- 컴퓨터 네트워크 프로토콜 디자인과 통신을 계층으로 나누어 개념적으로 설명한
- 물리 계층 :
    - 실제 장치들을 연결하기 위한 물리적, 전기적 사항들.
    단지 데이터 전기적인 신호(0,1)로 변환해서 주고받는 기능만 할 뿐.
    통신 케이블, 허브 등등
- 데이터 링크 계층 :
    - 물리 계층의 송수신 되는 정보의 오류와 흐름 관리.
    - 데이터 패킷에 캡슐화된 디지털 신호인 데이터 프레임을 관리.
    - 프레임에 물리적 주소 MAC을 부여하고 에러 검출, 재전송, 흐름제어 수행.
    - 보통 두 하위 계층인 매체 접근 제어(MAC) 계층과 논리 링크 제어(LLC) 계층으로 나뉨.
        - MAC 계층은 네트워크 매체에 대한 접근을 제어하고 물리적 주소를 기반으로 통신을 수행
        - LLC 계층은 네트워크 계층과의 인터페이스를 제공하고, 오류 및 흐름 제어 기능을 수행
    - 브릿지나 스위치
- 네트워크 계층 :
    - 분산된 네트워크 하나 또는 연결된 여러 네트워크의 노드 또는 머신을 통한 목적지까지 안전하고 빠르게 라우팅, 전달.
    - 라우터를 통해 경로를 선택하고, 논리적 주소를 정하고(IP), 경로에 따라 패킷을 전달 -> 데이터에 IP 헤더 붙음
    - 라우터
- 전송 계층 :
    - 포트 번호를 사용하여 송수신 프로세스를 구분하고, 신뢰성 있는 데이터 전송을 담당
    - 세그먼트 단위로 전송
    - TCP, UDP 주로 사용됨
- 세션 계층 :
    - 통신 세션을 설정하고 유지
    - 서로 다른 두 애플리케이션 간의 네트워크 조정을 담당
    - 네트워크 파일 시스템(NFS), 서버 메시지 블록(SMB) 사용
- 프레젠테이션 계층 :
    - 애플리케이션에서 전송하고 소비하는 데이터 자체의 구문과 관련
    - 데이터 암호화, 압축, 변환 등을 수행
    - JPEG, MPEG, GIF, ASCII 등
- 응용 계층 :
    - 최종 목적지로, 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행
    - HTTP, FTP, SMTP, POP3, IMAP, Telnet 등과 같은 프로토콜

---

# TCP

- 두 개의 호스트를 연결하고 데이터 스트림을 교환하게 해주는 중요한 네트워크 프로토콜
- 전송 계층에서 사용하는 규약
- 통신 과정 :
    - 데이터 스트림에서 받은 데이터를 분할하고 그 단위에 TCP 헤더를 붙여서 TCP 세그먼트 생성
    - TCP 세그먼트를 IP 데이터그램으로 변환
    - IP 데이터그램을 수신 애플리케이션으로 전송
- TCP 세그먼트
    - 헤더와 데이터 필드가 나뉘어져 있음
    
    ![image.png](attachment:d18e5b5b-c453-476f-8971-89b1c64995fe:image.png)
    
    - Source Port: 데이터를 발송하는 애플리케이션의 포트 번호
    - Destination Port: 데이터를 수신하는 애플리케이션의 포트 번호
    - Sequence Number(SYN): TCP 통신 과정에서 데이터를 일정 단위로 분할하는데, 분할된 데이터의 순서
    - Acknowledgment Number(ACK): 데이터를 수신하는 애플리케이션 입장에서, 다음으로 받고 싶은 TCP 세그먼트의 Sequence Number
- TCP 핸드셰이크
    - TCP에서 연결 초기화하는 과정
    - 순서
        1. 클라이언트가 서버에 접속을 요청하는 SYN 패킷을 전송 (SEQ = 100)
        2. 서버는 클라이언트의 SYN 요청을 받고, 클라이언트에게 SYN-ACK 패킷 전송(ACK = 101 SEQ = 1000)
        3. 클라이언트는 서버로부터 SYN-ACK 패킷을 받고, 서버에게 ACK 패킷을 전송(SEQ = 101, ACK = 1001)
        4. 성공적으로 완료시 TCP 연결 수립
        
- 흐름 제어
    - 수신자가 처리할 수 있는 만큼만 데이터를 전송하여 버퍼 오버플로우를 방지하는 것
    - 슬라이딩 윈도우 기법 사용
        - 송신자가 한 번에 보낼 수 있는 데이터의 최대 크기를 조정하여 흐름 조절
        - 전송하고 ACK 프레임을 수신하면 그 만큼씩 윈도우를 슬라이딩하면서 조절함
- 혼잡 제어
    - 혼잡을 방지하여 패킷 손실을 최소화하고. 안정적인 데이터 전송을 보장하는 것
    - 혼잡 윈도우 cwnd라는 개념을 사용
    - Slow Start
        - TCP 연결이 처음 시작될 떄, 너무 많은 데이터를 한 번에 보내지 않고 천천히 전송량을 증가.
        - cwnd의 크기를 2배씩 늘리면서 전송하다가, ssthresh 값을 초과하면 AIMD로 전환
    - AIMD
        - 혼잡을 방지하기 위해 윈도우 크기를 느리게 증가하고, 혼잡 발생하면 크게 감소
        - TCP Reno : 3개의 중복된 ACK가 측정되면 Fast Recovery가 실행되고 cwnd를 반으로 줄임. 타임아웃인 경우에는 1로 줄임
        - TCP Tahoe : 3개의 중복 ACK 받거나 타임아웃 되면 cwnd 1로 줄임
    - cubic
        - 세제곱 함수 꼴로 증가함
        - loss 지점을 최대한 천천히가서 정확한 지점을 찾아보자는 의미

---

# UDP

- 보안과 신뢰성보다 전송 속도와 효율성이 더 중요한 경우 사용
- 최소한의 프로토콜 메커니즘을 갖춘 간단한 무연결 통신 모델을 사용
- Best Effot
- 통신 과정 :
    - 데이터 스트림에서 받은 데이터에 UDP 헤더를 붙여 UDP 데이터그램을 생성
    - IP 계층에 전달
- UDP 데이터그램 구조
    - Source Port (16비트): 발신지 포트 번호
    - Destination Port (16비트): 목적지 포트 번호
    - Length (16비트): UDP 헤더와 데이터를 포함한 전체 길이
    - Checksum (16비트): 데이터 무결성을 검사하기 위한 값
- 비연결성
    - 연결 초기화 과정이 없음
    - receiver의 상태과 관계없이 전송
- 순서 보장 없음
    - 각 데이터 그램은 독립적으로 처리
    - 도착 순서가 바뀔 수 있지만 교정 메커니즘 x
- 흐름 제어, 혼잡 제어 없음
    - 패킷 손실 가능성
- 패킷 손실 보완 방법
    - FEC(Forward Error Correction) : 송신 측에서 원본 데이터에 여분의 복구 데이터를 추가로 전송하는 방식으로 작동.
    예시) 4개의 패킷을 전송할 떄, 이들의 XOR 연산 결과를 5번째 패킷으로 함께 보내면 복구 가능
    - RTP(Real-time Transport Protocol) : 각 패킷에 타임스탬프와 시퀀스 번호를 포함시켜 손실 및 재정렬 감지를 할 수 있게 UDP 위에서 돌아가는 프로토콜
- QUIC 프로토콜
    - UDP기반으로 하되, 신뢰성 있는 전송을 추가했음
    - TCP와 TLS가 서로 2번의 핸드셰이크를 하던 비효율을 제거하고 이를 하나로 줄임
    - 멀티플렉싱을 사용하여 여러 개의 독립적인 스트림을 생성 -> 한 스트림에서 손실이 일어나도 다른 스트림은 영향을 받지 않음.

---

# HTTP

- 웹에서 가장 기본이 되는 요청-응답 프로토콜
- 클라이언트가 요청을 보내면 서버는 그에 대한 응답 반환
- Stateless함. 각각의 요청은 독립적으로 처리. 이전 요청에 대한 정보 저장 x
- 구조
    - 요청 메세지 구조 :
        - Start Line - 메소드, 요청, 버전
        - Headers - Host, User-Agent, Aceept, Content-type, Authoization
        - Body - 서버로 전송할 데이터
    - 응답 메세지 구조 :
        - Start Line - 버전, 상태코드, 상태 메시지
        - Headers - Content-Type, Content-Length, Set-Cookie 등등
        - Body - 클라이언트에게 응답하는 데이터
- HTTP 메서드
    - GET은 리소스를 조회할 때 사용. 멱등성을 가지며, 캐시가 가능. 서버의 상태를 변경하지 않아야 하며, 요청 본문을 포함하지 않음
    - POST는 새로운 리소스를 생성할 때 사용. 멱등성이 없으며, 요청마다 서버의 상태가 변경될 수 있음. 요청 본문에 생성할 리소스의 데이터를 포함.
    - PUT은 리소스를 수정하거나 생성할 때 사용. 멱등성을 가지며, 동일한 요청을 여러 번 보내도 결과가 같음. 요청 URI에 해당하는 리소스가 없으면 새로 생성.
    - DELETE는 리소스를 삭제할 때 사용. 멱등성을 가지며, 같은 리소스에 대해 여러 번 삭제 요청을 보내도 결과는 동일.
    - PATCH는 리소스의 일부를 수정할 때 사용. PUT과 달리 전체 리소스가 아닌 일부만 수정할 때 사용되며, 멱등성은 보장되지 않음.

---

# HTTPS

- HTTP 통신을 암호화하여 데이터를 안전하게 전송하는 프로토콜임
- HTTP의 약점인 데이터 도청, 변조, 위조 등의 보안 문제를 해결함
- SSL/TLS 프로토콜을 통해 HTTP 통신을 암호화하고 보호함
- 동작 원리와 구조
    - SSL/TLS 핸드셰이크 과정
        1. Client Hello
            - 클라이언트가 지원하는 암호화 알고리즘 목록
            - 랜덤 데이터
            - 세션 ID
            - SSL/TLS 버전 정보를 서버에 전송
        2. Server Hello
            - 서버가 선택한 암호화 알고리즘
            - 서버의 랜덤 데이터
            - 디지털 인증서를 클라이언트에 전송
        3. 인증서 검증
            - 클라이언트가 서버의 인증서 유효성 검증
            - CA(Certificate Authority)의 공개키로 인증서 서명 확인
            - 인증서의 도메인명, 유효기간 등 검증
        4. 키 교환
            - 클라이언트가 Pre-master secret 생성
            - 서버의 공개키로 암호화하여 서버에 전송
            - 양쪽에서 master secret과 세션 키 생성
        5. 세션 시작
            - 생성된 세션 키로 대칭키 암호화 통신 시작
            - 이후의 모든 통신은 이 세션 키로 암호화됨
- 암호화 방식
    - 공개키(비대칭키) 암호화
        - 키 교환 과정에서 사용
        - 높은 보안성을 제공하나 연산 비용이 큼
    - 대칭키 암호화
        - 실제 데이터 전송 시 사용
        - 빠른 암호화/복호화가 가능
        - 양쪽이 동일한 키를 사용
- 주요 보안 기능
    - 기밀성(Confidentiality)
        - 데이터를 암호화하여 제3자가 내용을 볼 수 없게 함
        - 중간자 공격으로부터 데이터 보호
        - 개인정보, 결제정보 등 민감한 데이터 보호
    - 무결성(Integrity)
        - 메시지 인증 코드(MAC)로 데이터 변조 여부 확인
        - 전송 중 데이터 변경 시 즉시 탐지 가능
        - 해시 함수를 통한 데이터 무결성 검증
    - 인증(Authentication)
        - 디지털 인증서로 서버의 신원 보장
        - CA를 통한 신뢰할 수 있는 인증 체계
        - 피싱 사이트 등의 위장 공격 방지

---

# TLS / SSL

- 둘 다 서버, 애플리케이션, 사용자 및 시스템 간의 데이터를 암호화하는 통신 프로토콜
- 동작 방식 - 핸드셰이크
    1. Client Hello
        - 클라이언트(예: 브라우저)가 서버에게 TLS 버전, 암호화 방식(암호 스위트), 랜덤 값을 보냄
    2. Server Hello
        - 서버가 클라이언트의 요청을 확인하고, TLS 버전, 암호화 방식, 랜덤 값을 응답
        - 서버는 자신의 공개키가 포함된 인증서(SSL/TLS 인증서)를 클라이언트에게 보냄
    3. 인증서 검증
        - 클라이언트는 서버 인증서가 신뢰할 수 있는 기관(CA, Certificate Authority)이 발급한 것인지 검증
        - 인증서가 신뢰할 수 없으면 경고 표시 (예: "이 사이트는 보안 연결을 제공하지 않습니다")
    4. 세션 키 교환 (비대칭키 암호화 사용)
        - 클라이언트는 공개키(Public Key)를 사용하여 세션 키(Session Key)를 암호화
        - 서버는 자신의 개인키(Private Key)로 복호화하여 세션 키를 얻음
    5. 대칭키 암호화로 안전한 통신 시작
        - 이후부터는 대칭키 암호화(AES 등)를 사용하여 안전한 데이터 전송
        - 클라이언트와 서버가 같은 세션 키를 공유하기 때문에 암호화/복호화 속도가 빨라짐
- SSL과 TLS 차이점

| 구분 | SSL | TLS |
| --- | --- | --- |
| 개발 | 넷스케이프(Netscape) | IETF (Internet Engineering Task Force) |
| 최신 버전 | SSL 3.0 (더 이상 사용 안 함) | TLS 1.3 (2018년 발표) |
| 보안 수준 | 취약점 많음 (MITM 공격, POODLE 공격) | 보안 강화 (예: SHA-256, AEAD 암호화) |
| 핸드셰이크 속도 | 비교적 느림 | TLS 1.3에서는 0-RTT로 속도 개선 |
| 지원 여부 | 사용 금지됨 | 표준으로 사용 중 |
| 데이터 무결성 | MD5, SHA-1 사용 (안전하지 않음) | SHA-256, AEAD 사용 (더 안전함) |

---

# 대칭키 / 비대칭키 암호화 방식

- 대칭키 : 암호화 키와 복호화 키가 동일한 방식. 키를 교환해야한다는 문제가 있음. 사람이 증가할수록 전부 따로 키 교환을 해야하기 때문에 관리할 키가 많아진다는 단점이 있음
    - Diffie-Hellman 키 교환 방식으로 커버칠 수 있긴 함(P는 충분히 큰 소수, G는 적절한 정수)
        - 1번은 A ≡ G^a(mod P) 인 A를 2번에게 전송함. 이때 a는 1번만 알아야 하고 A는 모두가 알아도 상관 없음
        - 2는 B ≡ G^b(mod P) 인 B를 1번에게 전송하고 마찬가지고 b는 2번만 알아야 됨.
        - 1번은 B^a(mod P)를 계산하고 2번은 A^b(mod P)를 계산하면 같은 값이 나옴. 이를 키 값으로 사용하면 됨
- 비대칭키 : public키와 private 키를 두어 암호화와 복호화를 하는 방식. 키 교환 문제 해결
    - 핵심 개념 :
        - 공개키로 암호화하고 개인키로 복호화
        - 개인키로 서명하고 공개키로 검증
        - 알고리즘 종류 :
            - RSA : 큰 소수의 곱셈 활용
            - ECC : 타원 곡선 이론 기반
            - ElGamal : 이산 로그 문제 기반

---

# DNS

- 인터넷에서 도메인 이름을 IP주소로 변환하는 시스템
- 질의는 재귀적 질의를 이용함
- 계층 구조
    1. 루트 네임서버 (Root Name Server)
        - 인터넷의 최상위 DNS 서버
        - `.`(dot)으로 표시되는 루트 도메인 관리
        - 전 세계에 13개 루트 서버 클러스터 운영 (A~M 네임서버)
    2. TLD 네임서버 (Top-Level Domain Name Server)
        - `com`, `org`, `net`, `kr`, `jp` 같은 최상위 도메인을 관리
        - 예: `.com` 도메인은 Verisign이 관리, `.kr` 도메인은 KISA가 관리
    3. 권한 네임서버 (Authoritative Name Server)
        - 특정 도메인(예: `google.com`)에 대한 최종 IP 주소 정보를 제공
        - 웹사이트 운영자가 설정한 DNS 서버 (예: `ns1.google.com`)
    4. 로컬 DNS 서버 (ISP DNS, Recursive Resolver)
        - 사용자의 요청을 받아 DNS 계층을 탐색하고 결과를 반환
        - ISP(KT, SKT, LGU+) 또는 Google DNS (8.8.8.8) 같은 공용 DNS가 사용됨
- 동작방식
    1. 사용자가 브라우저에 도메인 이름 입력
        - 브라우저는 해당 도메인의 IP 주소를 찾기 위해 로컬 DNS 캐시 확인
    2. 로컬 캐시에 없으면 DNS 서버에 요청
        - 사용자의 네트워크가 ISP의 DNS 서버에 질의
    3. ISP DNS 서버가 캐시에 없으면 계층적으로 질의 진행
        1. 루트 네임서버
            - .com .org .net 같은 최상위 도메인 관리
            - 루트 서버는 해당 도메인을 관리하는 TLD 서버로 요청 전달
        2. TLD 네임서버
            - 해당 도메인을 담당하는 서버로 이동
            - 예를 들어 google.com을 담당하는 권한 네임서버 위치 제공
        3. 권한 네임서버
            - google.com에 해당하는 정확한 IP 주소 반환
    4. IP주소 반환 및 웹사이트 접속
    
- DNS 캐싱
    - 매번 루트 네임서버까지 조회하면 속도가 느려짐. 따라서 로컬 DNS 서버는 자주 조회하는 결과를 캐시에 저장하여 빠르게 응답
    - 브라우저 캐시
    - 운영체제 캐시
    - 로컬 DNS 서버 캐시
    - TTL 설정

---

# REST API

- REST 란?
    - 분산 시스템 설계를 위한 아키텍쳐 스타일
    - 웹과 같은 분산된 인터넷 규모의 **하이퍼** 미디어 시스템 의 아키텍처가 어떻게 동작해야 하는지에 대한 제약 조건을 정의
    - 자원을 이름으로 식별하고, 해당 자원의 상태(정보)를 구조화된 형식으로 표현하여, 서버와 클라이언트 간에 정보를 교환하는 방식을 따르는….
    - REST의 구성 요소
        - HTTP URI = 자원
        - HTTP 메소드 = 행위
        - MIME 타입 = 표현 방식
    - 제약 조건
        - Client / Server - 클라이언트와 서버는 독립적으로 구분되어있음
        - Stateless - 각 요청에 클라이언트의 context가 서버에 저장되어서는 안됨
        - Cacheable - 클라이언트는 응답을 캐싱할 수 있어야 함
        - Layered System - 클라이언트는 서버에 연결인지 미들웨어에 연결인지 알 필요 x
        - Code on demand(option) - 서버에서 코드를 클라이언트에게 보내서 실행할 수 있게 해야함
        - uniform interface - 자원은 유일하게 식별가능해야 하고, HTTP 메소드로 표현을 담아야하고, 메세지는 스스로를 설명해야 하고 하이퍼링크를 통해 애플리케이션의 상태가 전이되어야 함
    - 세부 규칙
        1. 슬래시 구분자 ( / )는 계층 관계를 나타내는데 사용한다.
        
        2. URI 마지막 문자로 슬래시 ( / )를 포함하지 않는다.
            - 즉 URI에 포함되는 모든 글자는 리소스의 유일한 식별자로 사용되어야 하며 URI가 다르다는 것은 리소스가 다르다는 것
            - 역으로 리소스가 다르면 URI도 달라져야 한다.
        3. 하이픈 ( - )은 URI 가독성을 높이는데 사용한다.
        
        4. 밑줄 ( _ )은 URI에 사용하지 않는다.
        
        5. URI 경로에는 소문자가 적합하다.
            - URI 경로에 대문자 사용은 피하도록 한다.
        6. 파일확장자는 URI에 포함하지 않는다.
            - REST API 에서는 메시지 바디 내용의 포맷을 나타내기 위한 파일 확장자를 URI 안에 포함시키지 않는다.
            - 대신 Accept Header 를 사용한다.
            - ex) `GET`: `http://restapi.exam.com/orders/2/Accept: image/jpg`
        7. 리소스 간에 연관 관계가 있는 경우
            - /리소스명/리소스ID/관계가 있는 다른 리소스 명
            - ex) GET: /users/2/orders (일반적으로 소유의 관계를 표현할 때 사용)
- 정의 : REST API는 REST 아키텍처 스타일을 따르는 API를 의미하며, 주로 HTTP 요청을 사용하여 데이터를 주고받는 방식
- 사용 이유 : 개발자 간 일관된 통신 규칙을 정해 업무 효울 높임. 요청 목적을 쉽게 알게 함

---

# JWT

- 정의 : 애플리케이션 간의 정보 교환을 위해 JSON 형식으로 정보를 포함하는 토큰
- 자체 포함형 토큰 : JWT가 모든 필요한 정보를 자체적으로 담고 있음
- 사용하는 이유 :
    - 무상태 인증 : JWT는 토큰 자체에 정보를 포함하고 있어 세션 상태 유지할 필요가 없음
    - 서버 간 부담 감소 : 서버는 인증 상태를 따로 관리하지 않아도 됨
    - 확장성 : 추가적인 저장소나 상태 관리 없어서 쉽게 확장 가능
    - 보안, 무결성 보장 : 서명을 통해 토큰의 무결성을 보장
    - 유연성, 다양한 적용 : 다양한 플랫폼과 언어에서 쉽게 구현 가능
- 동작방식
    1. 토큰 발급 : 로그인 성공하면 서버에서 JWT를 생성해서 클라이언트에게 발급
        1. 사용자 인증
            - 서버가 클라이언트에게 전달받은 인증정보 검증
        2. Payload 생성
            - JSON 형식 데이터
            - 필수 클레임 : 토큰 유효성 검증 및 관리를 위한 데이터(토큰 발급자, 토큰 제목, 토큰 대상, 만료 시간, 활성 시간, 발급 시간)
            - 공개 클레임 : 자유롭게 정의할 수 있는 클레임
            - 비공개 클레임 : 토큰 발급자랑 수신자만 알고 있는 클레임
        3. Header 생성
            - JSON 형식 데이터
            - 토큰 유형 : JWT
            - 서명 알고리즘 : HMAC, SHA256
        4. 서명 생성
            - 비밀키 사용해서 생성
            - Header, Payload 기반으로 Base64 인코딩
        5. JWT 발급
            - Access Token, Refresh Token
    2. 토큰 전송 : 클라이언트는 서버로부터 발급받은 JWT를 안전하게 저장하고 보호된 리소스 접근할 때마다 전송
        1. Authorization Header : Bearer 스키마
            - 장점 : 표준, Restful, 서버에서 쉽게 추출하고 검증
            - 단점 : CORS 이슈
        2. Cookie
            - 장점 : CORS 이슈 x, XSS 공격 방어에도 유리
            - 단점 : CSRF 공격 방버에 취약 - CSRF 토큰사용?
    3. 토큰 검증 : 서버가 클라이언트로부터 JWT 받으면 유효한 토큰인지 검증
        1. JWT 추출
            - Authorization Header, Cookie에서 추출
        2. JWT 파싱
            - Base64로 디코딩해서 Header, Payload, Signture를 분리
        3. 서명 검증
            - Header에 명시된 알고리즘과 비밀키를 사용해서 서명을 검증
            - 클라이언트로부터 받은 서명과 서버가 생성한 서명을 비교해서 일치여부 확인
        4. 클레임 검증
            - 만료시간, 토큰 발급자, 토큰 대상 유효성 검사
        5. 인증 성공/실패
        
    4. 권한에 따른 처리 : 서버는 JWT Payload에 포함된 사용자 정보, 권한을 통해서 인가 처리
        - RBAC - 역할 기반 접근 제어 -> payload에 담겨있는 역할 정보
        - ABAC - 속성 기반 역할 제어 -> payload에 담겨있는 속성 정보. 동적으로 접근 권한하여 유연
- JWT 구조 (Header, Payload, Signature)
    - aaaaaaaa.bbbbbbbbb.cccccccc 의 모습을 가지고 있음
        - a 부분은 헤더, b 부분은 페이로드, c 부분은 서명임
    - Header :
        - 주로 토큰의 유형과 서명된 알고리즘을 정의함.
        
        ```java
        {
          "alg": "HS256",
          "typ": "JWT"
        }
        
        ```
        
    - Payload :
        - 토큰에 담길 정보인 클레임을 포함함. 클레임은 사용자에 대한 정보나 추가 메타 데이터 포함가능
        
        ```java
        {
          "email": "hello@gmail.com",
          "username": "void",
          "iat": 1609239023,
          "exp": 1609242623
        }
        
        ```
        
        iat : 토큰 발행 시간
        exp : 토큰 만료 시간
        
    - Signature :
        - 헤더와 페이로드를 합친 뒤, 지정된 알고리즘으로 해시하고 비밀키로 서명한 결과
        - 서명은 토큰이 변조되지 않았음을 검증하는 데 사용.
        - 수신자는 같은 키와 알고리즘을 사용하여 헤더, 페이로드를 해시하고 이를 서명과 비교하여 유효성 검증
- JWT 서명 및 암호화 (HMAC, RSA, ECDSA)
    - HMAC (HS256) : 대칭키 서명
        - 서명과 검증을 같은 키 사용
        - 비밀키 노출되면 공격당하기 쉬움
    - RSA (RS256) : 비대칭키 서명
        - 서명과 검증을 다른 키 사용
        - 소수와 소인수 분해를 이용하여 키를 만듦
    - ECDSA (ES256) : 비대칭키 서명
        - 서명과 검증을 다른 키 사용
        - 타원곡선을 이용하여 키를 만듦

---

# OAuth

- 정의 : 사용자의 비밀번호를 직접 제공하지 않고도, 타사 애플리케이션이 사용자 정보를 안전하게 접근할 수 있도록 해주는 인증 및 권한 부여 프로토콜
- 구성 요소 :
    - Resource Server :
        - OAuth2.0 서비스를 제공하고 Resource를 관리하는 서버(ex - Google, Naver, Kakao, ...)
        - 클라이언트(Client) - 이 서버로 인증 서버에서 발급받은 Token을 넘겨개인 정보를 받을 수 있다.
    - Resource Owner :
        - 어플리케이션을 이용하려는 Resource Server의 계정을 소유하고 있는 사용자
    - Client :
        - Resource Server의 API를 요청하여 정보를 가져오려는 애플리케이션 서버
    - Authorization Server :
        - Clinet가 Resource Server의 서비스를 사용할 수 있게 인증하고,토큰을 발행해주는 인증 서버
            - Resource Owner가 이 서버로 정보 넘겨서 허가 코드 발급 받음
            - Client가 허가 코드를 이 서버로 넘겨 토큰 발급 받음
- 동작 순서 :
    1. 사용자가 클라이언트 애플리케이션에서 로그인 버튼을 클릭하면, 클라이언트는 OAuth 인증 서버로 이동하도록 리디렉션
    
    2. 사용자는 OAuth 인증 서버에서 로그인한 후, 애플리케이션이 특정 권한을 요청하는 것을 승인
    
    3. 인증 서버는 클라이언트에게 인가 코드(Authorization Code)**를 발급
    
    4. 클라이언트는 이 인가 코드를 인증 서버로 보내고, 액세스 토큰(Access Token)을 요청.
    
    5. 인증 서버는 인가 코드가 유효하면 액세스 토큰을 발급
    
    6. 클라이언트는 발급받은 액세스 토큰을 이용하여 리소스 서버(API)에서 사용자 데이터를 가져옴
    
- 액세스 토큰/리프레쉬 토큰
    - 액세스 토큰
        - 액세스 토큰은 클라이언트가 보호된 자원에 접근할 때 사용하는 인증 수단임.
        - 보통 API 요청의 Authorization 헤더에 포함하여 사용함.
        - 만료 시간이 짧게 설정되어 있으며, 보안상의 이유로 일정 시간이 지나면 사용 불가능해짐.
        - 액세스 토큰이 만료되면 사용자는 다시 인증 과정을 거쳐야 함.
    - 리프레쉬 토큰
        - 리프레쉬 토큰은 새로운 액세스 토큰을 발급받기 위한 용도로 사용됨.
        - 액세스 토큰이 만료되었을 때, 사용자가 다시 로그인하지 않아도 새로운 액세스 토큰을 발급받을 수 있음.
        - 수명이 길게 설정되며, 일반적으로 클라이언트가 직접 보관하지 않고 서버에서 관리함.
        - 리소스 서버가 아닌 인증 서버에서만 사용됨.

---

# 쿠키

- 정의 : 웹 서버에 의해 사용자의 컴퓨터에 설치되는 작은 데이터
- HTTP는 stateless한데, 사용하다 보면 stateful한 상황이 많이 필요함. 그럴 때 쿠키를 사용함.
- 쿠키 사용 이유
    - 웹 사이트 방문 정보 기억해 개인화된 서비스 제공
- 쿠키 사용 방법
    - 브라우저에 텍스트 파일 형태로 저장하고, 필요할 때 다시 읽음
    - 웹 서버의 제어 + 웹 브라우저 내 저장 및 전송
    - Set-Cookie 헤더를 통해 웹 서버 제어
    - 쿠키 사용의 기준
        - 도메인과 경로를 기준으로 웹 브라우저가 웹 서버에게 쿠키를 전송함.
        - 도메인 앞에 .이 있으면 모든 서브 도메인에 보낸다는 의미
    - 쿠키 유효 시간
        - Persistent Cookie : MaxAge or Expires 옵션 사용하여 유효시간 설정. 브라우저를 닫아도 삭제 x
        - Session Cookie : 유효시간 명시 x. 브라우저가 닫히면 삭제
- 쿠키의 단점
    - 보안 문제
        - HTTPOnly, Secure, SameSite 속성 설정을 통해 해결
            - HTTPOnly : 자바스크립트를 통한 쿠키 접근 차단. XSS 공격 예방
            - Secure : 쿠키가 HTTPS를 통해서만 전송되도록 함. MITM 방지용
            - SameSite : 쿠키가 퍼스트파티에서만 전송되도록 제한. CSRF 방지용
                - Strict : 퍼스트파티 쿠키 전송만 허용
                - Lax : 직접 방문 사이트 or 안전한 get 요청(서버 상태 변경하지 않는 요청)일 때
                - None : 모든 서드파티 크키 허용. Secure 옵션 설정된 상태에서만 작동
    - 브라우저 간 공유 불가
    - 네트워크 부하 증가
- 퍼스트파티 쿠키
    - 사용자가 직접 방문한 웹사이트에서 설정한 쿠키. 방문 웹사이트 도메인 = 쿠키 설정 도메인
    - 주로 세션 관리, 로그인 유지 등
- 서드파티 쿠키
    - 방문 웹 사이트 도메인 != 쿠키 설정 도메인
    - 주로 광고 타겟팅

---

# 세션

- 정의 : 컴퓨터의 프로세스가 서로를 인식한 후 데이터 송수신을 마칠 때까지의 상태 정보. stateful하게
- 사용 이유 : 서버에서 사용자의 로그인 상태나 특정 작업의 진행 상태를 기억하기 위해 사용
- 사용자 정보는 서버 측에서 관리해서 안전하고, 사용자 별 정보 제공이 가능함
- 쿠키의 단점을 뒤집으면 세션의 장점임
- 민감 정보의 안전한 저장
- 네트워크 오버헤드 감소
- 동작 방식 :
    - 사용자가 웹사이트에 접속하면 서버는 고유한 세션 ID를 생성
    - 생성된 세션 ID는 클라이언트(웹 브라우저)에 쿠키로 저장
    - 클라이언트가 서버에 요청을 보낼 때. 세션 ID를 포함하여 전송
    - 서버는 세션 ID를 확인하여 데이터 관리
- 세션과 쿠키의 차이점
    - 세션은 서버에 정보를 저장하고, 클라이언트는 세션 ID만 유지함.
    - 쿠키는 클라이언트(브라우저)에 데이터를 직접 저장함.
    - 세션은 서버에서 관리되므로 보안성이 높지만, 서버 리소스를 더 많이 소모함.
    - 쿠키는 클라이언트에서 관리되므로 서버 부담이 적지만, 보안에 취약할 수 있음.
- 세션 저장 방식
    - In Memory : 코드로 세션 저장
    - File Storage : express 코드에서 파일 생성하고 파일에 저장
    - Database : DB에 정보 저장
