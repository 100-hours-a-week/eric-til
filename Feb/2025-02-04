# 프로세스, 스레드 정의

- 프로세스 : 메모리 공간을 할당받아 연속적으로 실행되고 있는 프로그램
    - 운영체제에게 메모리 공간을 할당받고 독립적으로 실행
    - ex) 크롬 브라우저는 프로세스
	    
- 스레드 : 프로세스 내에서 동시에 여러 작업을 처리할 수 있는 흐름의 최소 단위
    - 프로세스 내에 존재하기 때문에 프로세스의 자원을 공유함
		- 자원을 공유하기 때문에 동시성 문제가 발생할 수 있음
		  
# 알아야 하는 이유

- 프로세스 : 자원 관리, 효율적인 작업 실행
- 스레드 : 동시성과 병렬성 활용, 자원 사용 최적화

### 메모리 공간의 독립성 관련 문제 상황

- MSA 에서 여러 서비스가 동일한 데이터를 다루어야 할 때, 각 서비스는 독립된 메모리 공간을 가지므로 일관성 유지에 신경써야됨. 
- 프로세스 간 통신(IPC) 설정이 잘못되면 데이터 일관성이 사라짐. 예를 들어 돈은 나갔는데 구매가 안되는 상황
- 서버 사이드 렌더링

### 자원 누수 방지 관련 문제 상황

- 스레드 시작과 종료를 명확하게 하지 않으면 메모리를 계속 잡아먹고 있음
- 이를 방지하기 위해서 프로세스 생명주기를 정확히 이해하고 관리해야함

### 동시성 문제 해결 관련 문제 상황

- 동시 접속을 처리할 때 각 요청을 별도로 처리하지 않으면 응답 시간이 저하될 수 있음
- 요청들이 공유 자원에 접근할 때 동기화 없이 접근하면 무결성 문제가 생길 수 있음
- 동시성 : 여러 작업 번갈아가며 실행. 논리적으로 동시에
- 병렬성 : 여러 작업이 실제로 동시에 실행. 물리적으로 동시에
	- 멀티 스레드는 동시성은 보장, 병렬성은 x
	  
#### 그럼 프로세스만 많이 사용하면 되는거 아닌가요? 2개 스레드에서 할 일을 2개의 프로세스에서 하면 되잖아요.

- 프로세스 간 전환 비용이 스레드 간 컨텍스트 스위칭 비용보다 큼
- 프로세스 내에 스레드끼리는 자원을 공유하기 때문에 데이터 공유가 프로세스 간 통신보다 수월함

#### 그럼 반대로 생각하면, 프로세스를 최대한 적게 사용하고 스레드를 최대한 많이 사용하면 좋은거네요?

- 동시성 문제가 발생할 수 있음
- 하나의 스레드에서 발생한 문제가 프로세스 전체에 영향을 끼칠 수 있음
- 스레드 관리 오버헤드가 증가하면 성능이 저하될 수 있음

# Context Switching

- OS의 커널(Kernel)에 의해서 수행
- 현재 진행하고 있는 Task(Process, Thread)의 상태를 저장하고 다음 진행할 Task의 상태 값을 읽어 적용하는 과정
- 프로세스의 정보는 PCB(Proccess Control Block)에 저장되었다가 다시 실행될 때 이 정보를 바탕으로 동작
- 스레드의 정보는 TCB(Thread~)

# 동작 방식

## 프로세스의 메모리 영역

- Code : 실행 코드나 명령어들이 기계어로 저장되는 영역
- Data : 전역 변수와 정적 변수가 저장되는 영역
- Stack : 지역변수, 매개변수, 리턴 값들이 저장되는 영역
- Heap : 동적으로 할당하는 데이터 저장되는 영역

## 프로세스의 동작 방식

- 로딩, 실행, 대기, 종료
	- 레디, 러닝, 블락 으로 알고 있는 내용
	- 러닝은 현재 사용되고 있는 상태, 레디 상태는 수행 가능한 상태(수행 시간이 끝나서 내려오고 다른 프로세스를 수행하기 위해서 일시적으로 멈춰있는 상태), 블락 상태는 러닝상태에 있던 프로세스가입출력을 요구하는 때가 있음 이때는 디스크를 읽어야되는데 디스크로 부터 읽는 작업은 시간이 많이 걸림. 그걸 기다리는 시간이 너무 아까우니까 잠깐 내려올래? 한 게 블락 상태임. 그럼 러닝이 비니까 레디에 있던게 올라옴. 디스크가 다 읽으면, 인터럽트라는 메커니즘을 통해 씨퓨가 데이터를 다 가져온걸 알게 되어서 디스크에서 읽은 데이터를 버퍼로 옮겨주고 블락 상태에 있던 놈을 레디로 옮겨줌. 

## 스레드의 동작 방식

- 프로세스 내에서 여러 스레드를 생성하여 병렬로 작업을 수행
- 스레드들은 프로세스가 가진 코드, 데이터, 힙 영역을 공유하면서 각각 독립적인 실행 흐름을 가짐
- 스레드도 생성, 실행, 대기, 종료 거침

| 단계  | 설명                         | 특징                                                           | 예시: 메모장 프로그램<br>              |
| --- | -------------------------- | ------------------------------------------------------------ | ----------------------------- |
| 생성  | 프로세스 실행 중 추가적인 스레드를 생성     | - 운영 체제가 스레드를 동적으로 생성 <br>- 각 스레드는 고유의 실행 흐름을 가짐             | 저장 스레드가 생성되어 비동기로 파일 저장을 처리함  |
| 실행  | 독립적인 실행 흐름으로 각 스레드가 작업을 처리 | - 스레드는 프로세스의 자원을 공유<br>- CPU 스케줄링에 따라 병렬적으로 실행               | 메모장의 메인 스레드는 글 작성 작업 수행       |
| 대기  | 스레드가 동기화나 외부 이벤트를 기다리는 상태  | - 스레드 간 동기화가 필요할 경우 대기 <br>- 파일 입출력, 네트워크 작업 등 외부 작업 완료까지 대기 | 저장 스레드가 디스크 쓰기 작업이 완료될 때까지 대기 |
| 종료  | 스레드의 작업이 완료되어 자원을 반환       | - 스레드가 점유한 자원을 운영 체제가 해제 - 프로세스 내의 다른 스레드는 영향을 받지 않음         | 저장 작업이 완료되면 저장 스레드가 종료        |


# Java Thread 사용 이유

- 동시성
- 응답성
- 자원 공유

# 사용 방법

- Runnable 인터페이스 활용
- Thread 클래스 활용

## Runnable 인터페이스 활용

```
class IncrementTask implements Runnable {
    private Counter counter;

    public IncrementTask(Counter counter) {
        this.counter = counter;
    }

    @Override
    public void run() {
        for (int i = 0; i < 1000; i++) {
            counter.increment();
        }
    }
}

```
- `Runnable` 인터페이스를 구현하는 클래스 생성
- `run()` 메서드 오버라이딩
- `Thread` 객체를 생성할 때 `Runnable` 구현체를 전달
- `start()` 메서드 호출

## Thread 클래스 활용

```
class IncrementThread extends Thread {  
    private Counter counter;  
    public IncrementThread (Counter counter){        
	    this.counter = counter;    
	}  
    @Override    
    public void run() {        
	    for ( int i = 0 ; i < 1000 ; i ++) {
	         counter.increment();        
	    }    
	}
}
```
- `Thread` 클래스를 상속하는 클래스 생성
- `run()` 메서드 오버라이딩
- 해당 클래스로 객체 생성 후 `start()` 메서드 호출

## 실행 방식 - Main클래스

```
public class Main {  
    public static void main(String[] args) {  
        Counter counter = new Counter();  
        IncrementThread t1 = new IncrementThread(counter);  
        IncrementThread t2 = new IncrementThread(counter);   // Thread 클래스  
		Thread t1 = new Thread(new IncrementTask(counter));  
        Thread t2 = new Thread(new IncrementTask(counter));  // Runnable 인터페이스
  
        t1.start();  
        t2.start();  
  
        try {  
            t1.join();  
            t2.join();  
        } catch (InterruptedException e) {  
            e.printStackTrace();  
        }  
  
        System.out.println("값: " + counter.getValue());  
    }  
  
}
```

## 쓰레드를 통제하자

| 메서드명           | 설명                                                     |
| -------------- | ------------------------------------------------------ |
| start()        | 새로운 스레드를 시작하고, run 메서드를 자동으로 호출                        |
| run()          | 스레드가 실행할 코드를 포함, 직접 호출하는 것이 아니라, start() 에 의해 자동으로 호출됨 |
| sleep(long ms) | 현재 실행 중인 스레드를 지정된 밀리초 동안 일시 중지                         |
| join()         | 특정 스레드의 실행이 완료될 때까지 현재 스레드를 대기                         |
| interrupt()    | 실행 중인 스레드에 종료 요청을 보냄.                                  |
- 단순히 run()을 호출하면 새로운 스레드가 생성되지 않고 현재 스레드에서 실행됨(오류는 x, 멀티 스레딩 효과가 없음)
- sleep(), join()은 InterruptedException이 발생할 수 있으므로 반드시 try-catch로 감싸야 함
-  join(100)처럼 안에 시간 넣을 수 있음
- sleep(), join()을 호출한 스레드에서 interrupt 받으면 InterruptedException 발생

## 동시성 문제

- 여러 스레드가 동시에 실행되면서 발생하는 예상치 못한 동작이나 오류

### 동기화 방법들

#### Synchronized 

- 4가지의 사용법 존재
	- synchronized method
		- 인스턴스 단위로 lock이 걸린다.
		- 메서드가 시작될 때부터 종료될 때까지 동기화가 발생한다.
		- 동일 인스턴스내에서 synchronized키워드가 적용된 곳에서는 lock을 공유한다. 

	- synchronized block
		- 인스턴스 단위로 lock이 걸린다.
		- block내부에서 동기화가 발생한다.
		- lock 객체를 지정하여 특정 대상에만 lock을 걸 수 있다.
		- lock을 객체로 설정하면 해당 인스턴스만 lock이 걸리고 .class형식으로 설정하면 클래스 단위로 lock을 건다.

	- static synchronized method
		- 클래스 단위로 lock이 걸린다.
		- 메서드가 시작될 때부터 종료될 때까지 동기화가 발생한다.
		- static synchronized와 synchronized가 혼용되어있을 때 각자의 lock으로 관리된다.

	- static synchronized block
		- 클래스 단위로 lock이 걸린다.
		- block내부에서 동기화가 발생한다.
		- lock객체를 지정하여 특정 대상에만 lock을 걸 수 있다.
		- lock을 객체로 설정하면 해당 인스턴스만 lock이 걸리고 .class형식으로 설정하면 클래스 단위로 lock을 건다.
		  
- 데이터 공유할 때 동기화 시킬 수 있음. 잘 안씀. 성능 떨어짐
- 임계영역으로 설정되어 하나의 쓰레드만 접근하도록 제한됨.

#### AtomicInteger

- Atomic 변수의 일종. AtomicLong, AtomicBoolean, AtomicReference 등도 있으며 동시성을 보장
- Compare-and-swap(CAS) 방식을 이용하여 동시성 제어를 함. 
	- 업데이트 될 변수(메모리값) : V
	- 예상되는 변수의 현재 값 : e
	- 업데이트 되는 새로운 값 : n
	- 을 이용해서 V와 e가 같은 경우 V의 값을 n으로 설정함
- 위 과정이 한 명령어 안에서 수행되기 때문에 원자성을 가지며 이는 동시성을 보장해줌
