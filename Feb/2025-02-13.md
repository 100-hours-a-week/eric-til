## HTTP 자격증명 헤더

- 정의 : 인증 과정에서 사용자의 자격을 확인하기 위해 사용되는 헤더. 접근 권한이 있는지 검증하기 위해 사용

- 클라이언트가 보호된 리소스에 접근 요청하면, 서버는 `401 Unauthorized` 응답과 `WWW-Authenticate` 헤더를 함께 전송하여 인증 방식 안내
- 클라이언트는 이를 받고 안내된 인증 방식에 따라 `Authorization` 헤더에 포함해 전송
- 프록시 서버에서도 자격증명 관리 헤더가 존재함

- 동작방식 : 안내된 인증 방식에 따라 `Authorization` 헤더에 포함해 요청과 함께 서버에 전송

- 사용 예시 :
    - 기본인증 - 간단하게 인증해야 할 때 사용
        - 동작 방식 :
            1. 클라이언트에서 Basic Authentication 전송
                1. 이름, 비밀번호를 base64로 인코딩 한 값을 `Authorization`  헤더에 포함하여
            2. 서버에서 인증처리
            3. 인증 성공 후 자원 접근 허용
            
    - 다이제스트 인증 - 사용자의 비밀번호를 직접 전송하지 않고 해시된 버전 전송
        - 동작 방식 :
            1. 서버는 `WW-Authenticate` 헤더에 nonce값과 realm 정보를 포함하여 보냄
            2. 클라이언트는 nonce 값과 realm 정보를 이용해 다이제스트 응답을 생성하고 해시하여 **`Authorization`**  헤더에 포함시켜 전송
            3. 서버는 응답의 해시 값과 자신이 독립적으로 생성한 해시 값을 비교, 일치 시 허용
    
    <aside>
    💡
    
    nonce? 
    
    한 번만 사용되는 숫자. 재전송 공격을 방지하기 위해 서버는 클라이언트에게 nonce를 보내줌. nonce를 비밀번호에 섞으면 바뀔때 마다 응답도 바뀌게 됨.
    
    </aside>
    
    - 베어러 토큰 - 사용자의 신원을 인증하고 요청 권한을 확인하는데 사용하는 보안된 토큰
        - JWT나 OAuth 2.0과 같은 토큰 기반 인증 시스템에서 사용
        - 동작 방식 :
            1. 토큰 획득
            2. 토큰을 이용한 요청
            3. 서버에서 인증 처리

---

## WWW-Authenticate 헤더

- HTTP 인증 프로세스에서 사용되며 서버가 클라이언트에게 어떤 방식으로 인증 정보를 제공해야 하는지 지정하는 역할
- 구조 :
    - `WWW-Authenticate: <auth-scheme> realm="<realm>", <other-directives>`
    - `<auth-scheme>`: 사용되는 인증 방식 (예: `Basic`, `Digest`, `Bearer`, `Negotiate` 등)
    - `realm="<realm>"`: 인증이 필요한 보호된 영역(리소스의 범위)을 나타냄
    - `<other-directives>`: 인증 방식에 따라 추가 정보 제공

---

## Authorization 헤더

- 클라이언트가 서버에 인증 정보를 전달할 때 사용.
- 구조 :
    - `Authorization: <auth-scheme> <credentials>`
    - `<auth-scheme>`: 사용되는 인증 방식 (예: `Basic`, `Bearer`, `Digest`, `Negotiate` 등)
    - `<credentials>`: 인증 정보 (예: 토큰, 사용자 인증 데이터 등)

---

## Bearer Token

- 클라이언트가 서버로 요청을 보낼 때 "토큰만 제시하면" 인증이 완료되는 방식
- 베어러 토큰 방식은 주로 JWT나 OAuth 2.0과 같은 토큰 기반 인증 시스템에서 사용
- 클라이언트는 서버로부터 받은 액세스 토큰을 **`Authorization`** 헤더에 포함하여 리소스에 접근 요청을 보냄. 토큰은 **`Bearer`** 다음에 공백을 두고 위치

---

## JSON Web Token (JWT)

- 정의 :  애플리케이션 간의 정보 교환을 위해 JSON 형식으로 정보를 포함하는 토큰
- 자체 포함형 토큰 : JWT가 모든 필요한 정보를 자체적으로 담고 있음
- 사용하는 이유 :
    - 무상태 인증 :  JWT는 토큰 자체에 정보를 포함하고 있어 세션 상태 유지할 필요가 없음
    - 서버 간 부담 감소 : 서버는 인증 상태를 따로 관리하지 않아도 됨
    - 확장성 : 추가적인 저장소나 상태 관리 없어서 쉽게 확장 가능
    - 보안, 무결성 보장 : 서명을 통해 토큰의 무결성을 보장
    - 유연성, 다양한 적용 : 다양한 플랫폼과 언어에서 쉽게 구현 가능

- 동작방식
    1. 토큰 발급 : 로그인 성공하면 서버에서 JWT를 생성해서 클라이언트에게 발급
        1. 사용자 인증
            - 서버가 클라이언트에게 전달받은 인증정보 검증
        2. Payload 생성
            - JSON 형식 데이터
            - 필수 클레임 : 토큰 유효성 검증 및 관리를 위한 데이터(토큰 발급자, 토큰 제목, 토큰 대상, 만료 시간, 활성 시간, 발급 시간)
            - 공개 클레임 : 자유롭게 정의할 수 있는 클레임
            - 비공개 클레임 : 토큰 발급자랑 수신자만 알고 있는 클레임
        3. Header 생성
            - JSON 형식 데이터
            - 토큰 유형 : JWT
            - 서명 알고리즘 : HMAC, SHA256
        4. 서명 생성
            - 비밀키 사용해서 생성
            - Header, Payload 기반으로 Base64 인코딩
        5. JWT 발급
            - Access Token, Refresh Token
    2. 토큰 전송 : 클라이언트는 서버로부터 발급받은 JWT를 안전하게 저장하고 보호된 리소스 접근할 때마다 전송
        1. Authorization Header : Bearer 스키마
            - 장점 : 표준, Restful, 서버에서 쉽게 추출하고 검증
            - 단점 : CORS 이슈
        2. Cookie
            - 장점 : CORS 이슈 x, XSS 공격 방어에도 유리
            - 단점 : CSRF 공격 방버에 취약 - CSRF 토큰사용?
    3. 토큰 검증 : 서버가 클라이언트로부터 JWT 받으면 유효한 토큰인지 검증
        1. JWT 추출
            - Authorization Header, Cookie에서 추출
        2. JWT 파싱
            - Base64로 디코딩해서 Header, Payload, Signture를 분리
        3. 서명 검증
            - Header에 명시된 알고리즘과 비밀키를 사용해서 서명을 검증
            - 클라이언트로부터 받은 서명과 서버가 생성한 서명을 비교해서 일치여부 확인
        4. 클레임 검증
            - 만료시간, 토큰 발급자, 토큰 대상 유효성 검사
        5. 인증 성공/실패
        
    4. 권한에 따른 처리 : 서버는 JWT Payload에 포함된 사용자 정보, 권한을 통해서 인가 처리
        - RBAC - 역할 기반 접근 제어 -> payload에 담겨있는 역할 정보
        - ABAC - 속성 기반 역할 제어 -> payload에 담겨있는 속성 정보. 동적으로 접근 권한하여 유연

---

## JWT 구조 (Header, Payload, Signature)

- aaaaaaaa.bbbbbbbbb.cccccccc 의 모습을 가지고 있음
    - a 부분은 헤더, b 부분은 페이로드, c 부분은 서명임

- Header :
    - 주로 토큰의 유형과 서명된 알고리즘을 정의함.
    
    ```java
    {
      "alg": "HS256",
      "typ": "JWT"
    }
    ```
    

- Payload :
    - 토큰에 담길 정보인 클레임을 포함함. 클레임은 사용자에 대한 정보나 추가 메타 데이터 포함가능
    
    ```java
    {
      "email": "hello@gmail.com",
      "username": "void",
      "iat": 1609239023,
      "exp": 1609242623
    }
    ```
    
    iat : 토큰 발행 시간
    
    exp : 토큰 만료 시간
    

- Signature :
    - 헤더와 페이로드를 합친 뒤, 지정된 알고리즘으로 해시하고 비밀키로 서명한 결과
    - 서명은 토큰이 변조되지 않았음을 검증하는 데 사용.
    - 수신자는 같은 키와 알고리즘을 사용하여 헤더, 페이로드를 해시하고 이를 서명과 비교하여 유효성 검증

---

## JWT 서명 및 암호화 (HMAC, RSA, ECDSA)

- HMAC (HS256) : 대칭키 서명
    - 서명과 검증을 같은 키 사용
    - 비밀키 노출되면 공격당하기 쉬움

- RSA (RS256) : 비대칭키 서명
    - 서명과 검증을 다른 키 사용
    - 소수와 소인수 분해를 이용하여 키를 만듦

- ECDSA (ES256) : 비채칭키 서명
    - 서명과 검증을 다른 키 사용
    - 타원곡선을 이용하여 키를 만듦

---

## 세션 기반 인증과의 비교

- 개념 비교
    
    
    | 구분 | 세션 기반 인증 | JWT 기반 인증 |
    | --- | --- | --- |
    | **저장 방식** | 서버에서 **세션 저장소(Session Store)** 에 세션 데이터를 저장 | JWT 자체에 **사용자 정보와 인증 데이터 포함** |
    | **인증 과정** | 서버가 클라이언트의 로그인 요청을 받아 **세션 ID를 생성**하고, 이를 쿠키에 저장하여 인증 유지 | 서버가 클라이언트의 로그인 요청을 받아 **JWT를 생성**하여 전달, 이후 클라이언트가 JWT를 포함하여 요청 |
    | **상태(Stateful) 여부** | **Stateful** (서버가 세션을 관리) | **Stateless** (서버는 상태를 저장하지 않음) |
    | **서버 확장성** | **낮음** (세션 정보를 서버에서 관리해야 하므로 여러 서버에서 동기화 필요) | **높음** (JWT는 자체적으로 인증 정보를 포함하므로 서버 간 공유 불필요) |
    | **보안** | 세션 ID 탈취 시 보안 위험 (세션 고정 공격 가능) | 토큰 유효 기간이 지나거나, 유출되면 재발급 필요 (보안 취약점은 해결 가능) |
    | **쿠키 사용 여부** | **쿠키 필수** (브라우저가 자동으로 세션 쿠키를 전송) | **쿠키 불필요** (Authorization 헤더로 전송, 또는 쿠키 사용 가능) |
    | **로그아웃 처리** | 서버가 세션을 삭제하면 즉시 로그아웃됨 | 토큰을 클라이언트에서 삭제해야 하지만, 토큰 자체는 유효 기간 동안 사용할 수 있음 |

- 과정 비교
    - 세션 기반 인증
        1. 사용자가 로그인 정보를 입력하여 서버에 요청
        2. 서버가 사용자의 정보를 확인하고, **세션 ID(Session ID)** 를 생성
        3. **세션 ID** 를 클라이언트의 **쿠키(Cookie)** 에 저장
        4. 이후 클라이언트가 요청할 때마다 **쿠키를 자동으로 전송**
        5. 서버는 세션 저장소에서 해당 **세션 ID가 유효한지 검사** 후 응답
        
    - JWT 기반 인증
        1. 사용자가 로그인 정보를 입력하여 서버에 요청
        2. 서버가 사용자의 정보를 확인하고, **JWT를 생성**하여 클라이언트에 전달
        3. 클라이언트는 JWT를 **로컬 스토리지(Local Storage) 또는 메모리** 에 저장
        4. 이후 클라이언트가 요청할 때마다 **Authorization 헤더에 JWT를 포함**하여 전송
        5. 서버는 JWT의 **서명을 검증**하여 사용자가 유효한지 판단

---

## Access Token / Refresh Token

| 구분 | Access Token | Refresh Token |
| --- | --- | --- |
| **목적** | API 요청 시 인증 및 권한 검증 | Access Token을 재발급하기 위한 용도 |
| **저장 위치** | 브라우저의 메모리, 쿠키, 로컬 스토리지 | HttpOnly, Secure 쿠키 또는 데이터베이스 |
| **만료 시간** | 짧음 (수분~수시간) | 김 (수일~수개월) |
| **보안 위험** | 탈취되면 악용 가능 (짧은 유효기간으로 최소화) | 탈취 시 Access Token 지속 생성 가능 |
| **서버 검증 여부** | JWT 자체 검증 가능 | 주로 데이터베이스에서 확인 |
| **재발급 가능 여부** | ❌ 불가능 | ✅ Access Token을 재발급 가능 |
| **저장 방식** | 클라이언트에서만 보관 | 서버에서 안전하게 보관하는 것이 일반적 |
- 엑세스 토큰과 리프레시 토큰을 함께 사용할 때의 이점
    - 사용자는 리프레시 토큰 덕분에 자주 로그인할 필요가 없음
    - 리프레시 토큰은 일반적으로 엑세스 토큰보다 더 안전하게 저장됨

---

## OAuth 2.0

- 정의 : 애플리케이션 간에 인증과 권한 부여를 안정하게 공유할 수 있도록 해주는 프로토콜

- 사용 이유 : 사용자 비밀번호를 노출하지 않고도, 애플리케이션이 사용자의 데이터에 안전하게 접근할 수 있도록 도와줌. 또 특정 데이터에 대한 접근 권한 선택 가능.

- 주요 요소 및 용어

![image.png](attachment:b68863ba-cf6b-49b4-97c6-734424a359b0:image.png)

- Resource Server :
    - OAuth2.0 서비스를 제공하고 Resource를 관리하는 서버(ex - Google, Naver, Kakao, ...)
    - 클라이언트(Client) - 이 서버로 인증 서버에서 발급받은 Token을 넘겨개인 정보를 받을 수 있다.

- Resource Owner :
    - 어플리케이션을 이용하려는 Resource Server의 계정을 소유하고 있는 사용자

- Client :
    - Resource Server의 API를 요청하여 정보를 가져오려는 ****애플리케이션 서버

- Authorization Server :
    - Clinet가 Resource Server의 서비스를 사용할 수 있게 인증하고,토큰을 발행해주는 인증 서버
        - Resource Owner가 이 서버로 정보 넘겨서 허가 코드 발급 받음
        - Client가 허가 코드를 이 서버로 넘겨 토큰 발급 받음

- 동작 순서

| 1. 사용자 로그인 요청 |  |
| --- | --- |
| 2. 클라이언트가 인증 요청을 인증 서버로 전송 | 클라이언트가 인증 서버 로그인 페이지로 리다이렉트. URL에 `client_id`, `response_type`, `scope`, `redirect_uri` 포함 |
| 3. 로그인 페이지 제공 |  |
| 4. 사용자의 ID/PW 입력 | 사용자가 인증 서버 로그인 페이지에서 자격 증명을 입력하고 제출 |
| 5. Authorization Code 발급 | 인증 성공 후 인증 서버가 `redirect_uri`에 `authorization_code` 포함하여 리다이렉트 |
| 6. 클라이언트로의 리다이렉션 | 사용자 브라우저가 `authorization_code`가 포함된 URL을 통해 클라이언트로 리다이렉트 |
| 7. Authorization Code와 Access Token 교환 | 클라이언트가 `authorization_code`를 인증 서버에 제출해 액세스 토큰 요청 |
| 8. Access Token 발급 | 인증 서버가 액세스 토큰(및 필요시 리프레시 토큰)을 클라이언트에 발급 |
| 9. 로그인 성공 | 클라이언트가 액세스 토큰을 사용해 사용자를 로그인 상태로 설정 |
| 10. Access Token으로 리소스 서버에 리소스 요청 | 클라이언트가 액세스 토큰을 사용하여 리소스 서버에 데이터/서비스 요청 |
| 11. 리소스 서버의 토큰 검증 |  |
| 12. 리소스 제공 | 토큰이 유효하면 리소스 서버가 요청된 데이터/서비스를 클라이언트에게 제공 |
| 13. 클라이언트에서 데이터 활용 |  |

---

## OAuth 1.0과의 차이점

| 비교 항목 | OAuth 1.0 | OAuth 2.0 |
| --- | --- | --- |
| **출시 연도** | 2010년 (RFC 5849) | 2012년 (RFC 6749) |
| **보안 방식** | **암호화된 서명 방식** (HMAC-SHA1, RSA-SHA1) | **Bearer Token 방식** |
| **토큰 형태** | Request Token / Access Token | Access Token / Refresh Token |
| **액세스 토큰 전송 방식** | HTTP 요청 시 서명 필요 | HTTP 헤더에서 **Bearer Token**으로 간단하게 전송 |
| **클라이언트 인증** | **Consumer Key + Secret**을 사용 | **Client ID + Secret**을 사용 (더 유연한 방식) |
| **HTTPS 요구 여부** | 필수 아님 (하지만 권장됨) | **반드시 HTTPS 사용** |
| **복잡성** | **복잡함** (각 요청마다 서명 필요) | **간단함** (토큰 기반 인증) |
| **사용성** | 모바일/웹 애플리케이션에 적용하기 어려움 | 모바일/웹 애플리케이션에 최적화 |
| **확장성** | REST API에서 사용 가능하지만 제한적 | REST API 및 다양한 인증 방식 지원 (SAML, OpenID Connect 등) |

---

## 보안 강화 대책 (XSS, CSRF, 토큰 탈취 방지)

- XSS : 공격자가 악성 스크립트를 삽입하여 사용자의 브라우저에서 실행되도록 유도하는 공격
    - XSS 방지 대책
        - 쿠키에 중요한 정보를 담지 x
        - 정보를 암호화
        - HTTP-Only 쿠키 사용
        - textContent 사용
        - CSP(Content Security Policy) 적용 - 신뢰할 수 없는 스크립트 실행 차단

- CSRF : 사용자의 인증된 세션을 악용하여 공격자가 원하지 않는 요청을 보내는 공격
    - CSRF 방지 대책
        - CSRF 토큰 사용
        - SameSite 쿠키 설정 - `Strict` 또는 `Lax`로 설정하여 다른 사이트에서의 요청을 제한
        - Referer / Origin 검사 - 요청의 `Referer` 또는 `Origin` 값을 확인하여 신뢰할 수 있는 도메인에서 온 요청만 처리

- 토큰 탈취 : 인증 토큰이 탈취되면 공격자가 사용자 계정으로 접근 가능
    - 토큰 탈취 방지 대책
        - 토큰을 안전한 곳에 저장 - 로컬 스토리지 x
        - 토큰 만료 시간 설정 및 갱신
        - HTTPS 사용
        - Bearer 토큰 탈취 방지 - nonce 사용해서 재전송 공격 막기

---

## 예시 질문

### HTTP 자격증명 헤더가 웹 어플리케이션 보안에서 어떤 역할을 하는지 설명해주세요

1. 사용자의 신원을 확인하고 보호하기 위한 인증 정보를 포함하고 있어 서버와 클라이언트 간의 보안 통신이 가능하게 함. 사용자 인증, 권한 부여, 보안 강화를 위한 암호화를 맡고 있음

---

### WWW-Authenticate / Authorization 헤더의 차이점에 대해서 설명해주세요

1. `WWW-Authenticate` 헤더는 서버가 클라이언트에게 인증을 요구할 때 사용. 클라이언트가 어떤 인증 방식으로 요청을 보내야하는지 알려줌
2. `Authorization`은 클라이언트가 서버에 인증 정보를 포함하여 요청할 때 사용

---

### JWT가 어떤 구성 요소로 이루어져 있으며, 각 요소의 역할은 무엇인지 설명해주세요

1. 위에 있음. 헤더 페이로드 서명~

---

### JWT 검증시 서버에서 수행하는 주요 절차에 대해서 설명해주세요

1. JWT 형식 확인 - H.P.S 인지
2. 서명 검증 - 서버가 보유한 비밀 키 또는 공개 키를 사용하여 서명 생성, 일치하는지 비교
3. 토큰 만료 시간 검사 
4. 발급자 및 대상 검증 - 어떤 서버가 발급했는지(iss), 어떤 클라이언트가 사용할 수 있는지(aud)
5. 권한 검증 - payload에 있는 role, scope 등을 확인하여 권한이 있는지 검증

---

### Access Token과 Refresh Token 두 토큰의 차이와 각각의 역할, 그리고 토큰 갱신 시 고려해야 할 사항에 대해 설명해 주세요.

- Access Token
    - API 요청 시 인증에 사용
    - 만료 시간이 짧음(예: 15~30분)
    - 탈취되면 곧바로 악용될 위험이 있음

- Refresh Token
    - Access Token이 만료되었을 때 새로운 Access Token을 발급하는 데 사용
    - 만료 시간이 김(예: 1주일~1개월)
    - 보안을 위해 서버에서만 저장하고 관리하는 것이 일반적
- 토큰 갱신 시 고려 사항
    1. Refresh Token 저장 위치
        - 클라이언트 측 저장 x (보안 위험)
        - 서버 DB 또는 Secure Cookie에 저장
    2. Refresh Token 탈취 방지
        - Refresh Token을 재사용하지 못하도록 한 번 사용 후 폐기
        - IP, 기기 정보 등을 활용하여 변조 여부 확인
    3. Access Token 만료 전략
        - 짧은 만료 시간을 설정하여 보안 강화

---

### 왜 HTTPS가 토큰 기반 인증에서 필수적인지 설명해주세요

- HTTPS를 사용하면 SSL/TLS 암호화를 통해 토큰이 보호됨
- 재전송 공격을 방지하여 토큰이 가로채여도 재사용되지 않음
- 데이터가 전송 중 변조되지 않도록 보호
- 클라이언트는 신뢰할 수 있는 서버에만 토큰을 전송
- HTTPS는 서버의 신원을 인증서로 보증

---

### JWT나 OAuth기반 인증에서 발생할 수 있는 보안 취약점 / 이를 보완하기 위한 대책에는 어떤 것들이 있는지 설명해주세요

- JWT
    1. 토큰 탈취
        - 취약점: XSS나 안전하지 않은 저장소를 통한 토큰 유출
        - 보완책: HttpOnly 플래그 사용, 짧은 만료 시간 설정, 로컬 스토리지 사용 금지, 토큰 순환 구현
    2. 서명 알고리즘 취약점
        - 취약점: none 알고리즘 사용이나 약한 알고리즘으로의 변경 시도
        - 보완책: 서버 측에서 알고리즘 강제 지정, 안전한 서명 알고리즘 사용(HS256 이상)
    3. 토큰 재사용
        - 취약점: 만료되거나 폐기된 토큰의 재사용 시도
        - 보완책: 토큰 블랙리스트 관리, 토큰 식별자(jti) 사용, 사용 횟수 제한

- OAuth
    1. 인증 코드 인터셉트
        - 취약점: 인증 코드 탈취를 통한 액세스 토큰 획득
        - 보완책: PKCE 사용, 짧은 코드 만료 시간, 1회성 코드 사용 보장
    2. CSRF 공격
        - 취약점: 인증 요청 위조를 통한 권한 탈취
        - 보완책: state 파라미터 필수 사용, CSRF 토큰 검증
    3. 리다이렉션 URI 조작
        - 취약점: 악의적인 URI로 인증 정보 탈취
        - 보완책: URI 화이트리스트 관리, 정확한 매칭 검증, 와일드카드 사용 금지
