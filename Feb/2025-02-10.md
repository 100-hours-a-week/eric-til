| **개념**           | **한줄 정리**                                                        | **비고**                                                                                                                                                        |
|------------------|------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **공유 자원**       | 여러 사용자, 프로세스가 동시에 사용하는 시스템 내 자원                        | - 리소스 낭비 방지, 효율성 극대화를 위해 사용 <br> - 공간을 공유하여 프로세스 간 자원 사용 허용                                                                           |
| **임계 영역**       | 공유 자원에 접근하는 프로그램 코드 일부분                                   | - 여러 프로세스나 스레드가 동시에 접근하면 문제가 생김                                                                                                                       |
| **동기화**         | 충돌이나 데이터 무결성 문제 방지, 올바른 순서와 조정을 보장해줌. 신호등 같은 역할           | - 데이터 무결성 손실, 데이터 경합, 데드락을 막고 안전한 소프트웨어 설계하기 위해 사용                                                                                             |
| **락 (Lock)**     | 하나의 스레드나 프로세스가 자원을 점유할 경우 다른 애가 접근하지 못하도록 제어             | - 스핀락, 낙관적 락, 뮤텍스, 리드-라이트 락                                                                                                                           |
| **원자성**         | 완전히 실행되거나, 아예 실행되지 말거나                                       |                                                                                                                                                                |
| **상호배제**       | 하나의 프로세스가 임계 영역에서 실행 중일 때, 다른 프로세스는 임계 영역에 들어갈 수 없음        |                                                                                                                                                                |
| **진행**          | 공유 자원에 접근 중인 프로세스가 없고, 대기 중인 프로세스가 있다면 반드시 임계 영역에 들어가 실행되어야 함 |                                                                                                                                                                |
| **유한한 대기**     | 공유 자원에 접근 요청하면, 무한히 기다리지 않고 언젠가는 실행 기회를 보장받아야 함             |                                                                                                                                                                |
| **데드락**         | 스레드 간 자원 점유 순서가 꼬여 무한 대기에 빠질 수 있음                             | - 1번은 a를 갖고 b를 기다리고, 2번은 b를 갖고 a를 기다리면 교착됨                                                                                                          |
| **Race Condition** | 실행 순서에 따라 예측 불가능한 결과 초래                                    | - SNS 게시물의 '좋아요' 수를 여러 사용자가 동시에 클릭할 때, 동기화가 제대로 되지 않으면 일부 클릭이 무시되거나 잘못된 최종 카운트가 표시될 수 있음                                                    |
| **기아 현상**       | 자원 할당을 계속 받지 못하고 대기하는 상태                                    |                                                                                                                                                                |
| **락-프리 (Lock-Free)** | 여러 스레드가 동일한 공유 데이터 값을 업데이트하려고 시도할 수 있지만 그중 하나만 성공       | - 논 블로킹이 보장되어야 함. CAS 연산 이용 <br> - 다른 스레드가 계속 방해한다면 기아가 발생하여 계속적으로 수행을 실패                                                                 |
| **웨이트-프리 (Wait-Free)** | 각 스레드는 필요한 작업을 실행하고 있으며, 항상 진행 중                           | - 락-프리의 ‘다른 스레드가 계속 방해한다면’이 해결된 알고리즘                                                                                                              |
| **스핀락**         | 한 스레드가 점유하고 있을 때, 다른 스레드는 락이 해제되기를 기다리며 계속 반복적으로 락 상태 확인 | - busy-waiting <br> - 락 점유 시간 제한 <br> - 다중 코어에 적합                                                                                                       |
| **낙관적 락**       | 락을 사용하지 않는 방법. 충돌 발생하면 롤백을 통해 해결                              | - 충돌 감지 방식 <br> - 낙관적인 접근 방식 <br> - 주로 읽기 중심 시스템에서 사용                                                                                            |
| **뮤텍스 (Mutex)** | 락의 소유권과 해제 권한을 특정 스레드에 부여                                   | - 락이 점유된 상태에 접근 시도하면 OS의 뮤텍스 대기 큐에 진입하여 대기 상태로 전환 <br> - 배타적 접근 보장 <br> - 운영체제 지원 <br> - 락 소유권                              |
| **조건 변수**       | 조건 충족될 때까지 대기하거나, 신호를 보내 대기 중인 스레드를 깨워 실행 재개               | - 조건이 충족될 때만 스레드를 깨움 <br> - 락 해제됐다고 조건 충족 안됐는데도 뮤텍스 대기 큐가 스레드 깨우면 안 되므로 조건 변수로 제어                                               |
| **Read-Write Lock** | **읽기(Reader)** 작업과 **쓰기(Writer)** 작업을 구분하여 락 관리                | - Reader-Writer 구분 <br> - 동시성 지원 <br> - 환경 의존성                                                                                                         |
| **세마포어 (Semaphore)** | 공유된 자원에서 동기화 대상이 하나 이상일 때 사용하는 방법                          | - 뮤텍스처럼 소유하는 것이 아님 <br> - v연산 p연산을 통해 동작 <br> &nbsp;&nbsp;&nbsp; - p연산 (wait): 세마포어 값을 감소, 0이면 블록 <br> &nbsp;&nbsp;&nbsp; - v연산 (signal): 세마포어 값을 증가, 대기 프로세스 깨움 |
| **분산 락**         | 하나의 자원에 대해 한 번에 하나의 서버만 작업을 수행할 수 있음                       |                                                                                                                                                                |


## 공유 자원이란 무엇이며, 왜 시스템에서 공유 자원을 사용해야 할까요? 실생활 또는 개발 경험에 빗대어 설명해주세요.

1. 여러 사용자가 동시에 접근하거나 사용하는 자원. 모든 사용자에게 개별 자원 제공하는 것은 비효율적임. 동시성을 지원할 수 있음. 일관성 유지가 쉬움. 
Git에서 여러 개발자가 같은 코드 저장소를 공유하는 것. 물론 충돌이 날 수 있지만, 코드 관리하기가 편함

---

## 임계 영역의 정의와 중요성을 설명하고, 임계 영역을 보호하지 않았을 때 발생할 수 있는 가장 심각한 문제는 무엇이라고 생각하십니까?

1. 둘 이상의 프로세스나 스레드가 동시에 접근하면 안 되는 공유 자원에 접근하는 코드 영역. 데이터 일관성을 유지하고 경쟁 상태를 방지하는데 중요한 역할을 함. 가장 심각한 문제는 데이터 불일치라고 생각함. 시스템 신뢰성이 떨어지면 사용자가 없어지기 때문에.

---

## 동기화 메커니즘이 필요한 이유를 데이터 무결성과 관련지어 설명해주세요. 동기화가 없다면 발생할 수 있는 문제 3가지 이상을 예시와 함께 설명해주세요.

1. 여러 스레드나 프로세스가 공유 자원에 접근할 때, 동기화 없이 동시에 데이터 변경이 일어나면 예상치 못한 값이 저장될 수 있음. 이를 동기화 매커니즘을 통해 방지. 

    1. 데이터 무결성 손실
        - 동시에 공유 데이터를 수정할 때 의도하지 않은 결과가 발생할 수 있음
        - 예: 온라인 쇼핑몰에서 재고가 1개 남은 상품을 두 명의 고객이 동시에 구매하려 할 때, 재고 확인과 주문 처리가 제대로 동기화되지 않으면 실제로는 없는 재고가 판매되는 문제
    2. 데이터 경합
        - 실행 순서에 따라 예측 불가능한 결과 초래
        - 예: SNS 게시물의 '좋아요' 수를 여러 사용자가 동시에 클릭할 때, 동기화가 제대로 되지 않으면 일부 클릭이 무시되거나 잘못된 최종 카운트가 표시될 수 있음
    3. 데드락
        - 스레드 간 자원 점유 순서가 꼬여 무한 대기에 빠질 수 있음
        - 예: 한 스레드가 A 자원을 점유한 상태에서 B를 기다리고, 다른 스레드가 B를 점유하며 A를 기다릴 경우 시스템이 멈출 수 있습니다.

---

## 락의 기본적인 개념과 동작 방식을 설명해주세요. 락이 데이터 무결성을 어떻게 보장하는지 원자성 개념과 함께 설명해주시면 좋겠습니다.

1. 하나의 스레드나 프로세스가 자원을 점유할 경우 다른 애가 접근하지 못하도록 제어. 
스레드가 락을 점유하면 다른 스레드는 락 풀릴 때까지 대기 상태로 기다려야됨.
원자성은 모든 작업이 완전히 실행되거나, 전혀 실행되지 않는 것을 의미하는데, 락을 사용하면 
작업 중간에 다른 스레드가 개입할 수 없기 때문에 원자성을 보장하며 이는 무결성을 지킴

---

## 뮤텍스와 세마포어의 차이점을 설명하고, 각각 어떤 상황에서 사용하는 것이 적절한지 예시를 들어 설명해주세요.

1. 뮤텍스 : 한 스레드, 프로세스에 의해 소유될 수 있는 key를 기반으로 한 상호배제 기법
2. 세마포어 : 현재 공유자원에서 접근할 수 있는 스레드, 프로세스의 수를 나타내는 값을 두어 상호배제 달성
3. 차이점 : 
    1. 동기화 대상의 갯수
        1. Mutex는 동기화 대상이 only 1개일 때 사용
        2. Semaphore는 동기화 대상이 1개 이상일 때 사용
        
    2. 세마포어는 뮤텍스가 될 수 있지만, 뮤텍스는 세마포어가 될 수 없음
        1. Mutex는 0, 1로 이루어진 이진 상태를 가지므로 Binary Semaphore
        
    3. Mutex는 자원 소유 가능 + 책임을 가지는 반면, Semaphore는 자원 소유 불가
        1. 뮤텍스는 상태 0, 1 뿐이므로 Lock 가질 수 있음
        
    4. Mutex는 소유하고 있는 스레드만이 이 Mutex를 해제할 수 있음
        1. 반면, Semaphore는 Semaphore를 소유하지 않는 스레드가 Semaphore를 해제할 수 있다.
        
    5. Semaphore는 시스템 범위에 걸쳐 있고, 파일 시스템 상의 파일로 존재한다.
        1. 반면, Mutex는 프로세스의 범위를 가지며 프로세스 종료될 때 자동으로 Clean up 된다.
4. 뮤텍스 : 파일쓰기, 1대의 프린터
5. 세마포어 : 생산자-소비자 문제

---

## 조건 변수(Condition Variable)는 왜 뮤텍스와 함께 사용해야 할까요? 조건 변수의 역할과 뮤텍스와의 협력 관계를 설명해주세요.

1. 조건 변수의 역할은 조건이 충족될 때까지 스레드를 대기 상태로 만들고 충족시 깨어나도록 관리하는 역할을 함. 뮤텍스 없이 조건변수를 사용하는 경우 조건이 변경되는 순간에 경쟁 상태가 발생할 수 있음. 스레드가 조건을 기다리는 동안 뮤텍스를 잠금 상태로 유지하면, 다른 스레드가 공유 자원을 수정할 수 없음. 

---

## 뮤텍스는 데드락 발생 가능성이 있습니다. 데드락의 발생 조건 4가지를 설명하고, 데드락을 예방하기 위한 방법 3가지 이상을 제시해주세요.

1. 발생 조건 4가지
    1. 상호 배제
    2. 점유와 대기 - 자원을 획득한 상태에서 다른 자원을 획득하고자 대기
    3. 비선점 모드 - 자원 강제로 뺏지 못하고 대기해야함
    4. 원형 대기 - 점유와 대기를 하는 프로세스 간의 관계가 원을 이룸
    
2. 예방방법
    1. 비선점 예방 - 선점 방식으로 변환
    2. 점유와 대기 예방 - 자원을 점유한 상태에서 다른 자원 기다리지 못하게 전부 할당하거나 아예 할당하지 않는 방식 적용
    3. 원형 대기 예방 - 자원을 한 방향으로만 사용하도록 설정

---

## 낙관적 락(Optimistic Lock)은 충돌이 적을 것이라고 가정하고 작동합니다. 만약 충돌이 빈번하게 발생한다면 낙관적 락의 성능은 어떻게 될까요? 낙관적 락의 장점과 단점을 비교 설명해주세요.

1. 충돌이 자주 일어나면 롤백이 빈번해지고, 이 과정은 자원을 소모하게 되어 성능이 저하됨
2. 장점 : 
    1. 락을 걸지 않아 높은 동시성 보장
    2. 데드랑 방지
    3. 락 대기가 없으니 트랜지션 지연도 없음
    
3. 단점 : 
    1. 충돌 시 재시도 필요
    2. 충돌 감지 비용 : 버전 번호나 타임스탬프 관리 오버헤드가 존재함
    3. 일관성 위험

---

## 데이터베이스 커넥션 풀 또는 스레드 풀을 설계할 때 세마포어(Semaphore)를 어떻게 활용할 수 있을까요? 세마포어의 장점을 활용하여 자원 관리 효율성을 높이는 방안을 설명해주세요.

1. 커넥션 풀이나 스레드 풀을 설계할 때 세마포어에 값을 설정하여 값만큼만 실행할 수 있게 조절할 수 있음. 이렇게 하면 자원을 과다 사용하는 것을 방지할 수 있음. 또 세마포어는 FIFO을 사용하기 때문에 자원 독점없이 공정하게 사용할 수 있어 자원 관리 효율성을 높일 수 있음

---

## JavaScript 프레임워크에서 비동기 작업을 처리하고 상태 관리를 할 때 동시성 문제를 어떻게 고려해야 할까요?

1. 질문이 잘 이해가 가지 않음. 일단 이해한 대로 답변
    1. 경쟁 상태 방지 - 여러 비동기 작업의 실행 순서 보장
    2. 상태 일관성 유지 - 불변성 원칙 준수, 원자성 준수
2. 동시성 문제 해결방안
    1. async/await
    2. Redux
    3. Recoil
