# 시스템 아키텍처 개요
## 아키텍처
- 시스템의 구성요소와 관계 구조 설계
- 구성 요소 (하드웨어, 소프트웨어, 데이터) 간의 관계(상호작용) 고수준(전체적인 큰 틀) 설계
- 확장성, 안정성, 유지보수성 보장
### 주요 요소
- 구성 요소 : 시스템 기본 단위 - 소프트웨어 모듈, 하드웨어 장치, 네트워크 장비 등이 포함
- 인터페이스 : 구성 요소끼리 상호작용 정의 규약 - 데이터 전송, 명령어 실행 등의 방법을 명시(API 같은)
- 데이터 흐름
- 구성 요소 간의 관계 : 어떻게 연결, 상호작용하는지 정의
### 중요성
- 시스템 성능, 확장성
- 유지보수 및 관리 용이성
	- 모듈화되면 유지보수가 용이하지만, 모듈 간 프레임워크 버전이 다르거나 하는 단점이 있을 수
- 시스템 안정성 및 신뢰성
- 비용 절감
# 아키텍처 스타일
## 모놀리식 아키텍처
- 단일 코드베이스
	- 모든 기능이 하나의 코드 베이스 안에서 관리
	- 구성 요소들이 통합되어 하나의 애플리케이션 형성
	- 관리가 단순, 일관성
	  
- 강한 결합도
	- 구성 요소 간 의존성이 높음
	- 전체 애플리케이션 동작은 보장, 테스트와 수정이 어려움

- 단일 배포 단위
	- 전체 애플리케이션이 하나로 패키징되어 배포
	- 모든 구성 요소 함께 배포, 작은 변경이라도 전체 재배포가 필요
	- 배포 과정 간편하지만 리스크가 큼

- 장점 : 
	- 단순한 개발, 배포
	- 통합 테스트 용이
	- 기술 스택 일관성
	  
- 단점:
	- 유지 보수 어려움
	- 확장성 제한
	- 배포 리스크, 오래 걸림

- 적용 예시 : 
	- 소규모 프로젝트
	- 일관된 환경 필요
	- 빠른 시장 출시
	- 통합 시스템
## 클라이언트-서버 아키텍처(3-Tier)
- 네트워크를 통해 클라이언트와 서버 간에 작업 분리
- 모놀리식 아키텍처 밑에 있다고 생각
- Presentation tier, Application tier, Data tier 로 분리
  
- 구성요소 : 
	- 클라이언트
	- 서버
	- 네트워크
	- 프로토콜

- 장점 : 
	- 중앙 집중화 : 서버에서 데이터 중앙 집중 관리
	- 유지보수 용이성 : 모놀리식에 비해 높다
	- 확장성 : 모놀리식에 비해 높다
	- 안정성 및 신뢰성 : 서버에서 관리하니까 일관성, 무결성

- 단점 : 
	- 서버 부하
	- 네트워크 의존성
	- 비용
	- 복잡성 증가

- 적용 사례 : 
	- 웹 애플리케이션
	- 모바일 애플리케이션
	- 엔터프라이즈 애플리케이션
	- 온라인 게임
## 마이크로서비스 아키텍처 (MSA)
- 애플리케이션을 여러 개의 독립적이고 작은 서비스로 나눠 설계
- 각 서비스는 독립적으로 배포 및 운영, 각자 비즈니스 로직
- 서로 RESTful API 또는 메시지 브로커를 통해 통신
- 서비스 간 결합이 느슨해야 함

- 구성요소 : 
	- 독립적인 서비스
	- API 게이트웨이 : 클라이언트 요청을 적절한 서비스로 라우팅, 각 서비스 엔드포인트 관리
	- 서비스 간 통신 : RESTful API, 메시지 브로커, gRPC 등 다양한 통신 방식 사용
	- 데브옵스 도구 : : CI/CD 파이프라인, 컨테이너화 도구(Docker), 오케스트레이션 도구(Kubernetes) 등으로 서비스의 지속적 통합 및 배포를 지원

- 장점 : 
	- 확장성 : 독립적으로 확장 가능
	- 유지보수 용이성 : 코드베이스가 작아져 유지보수 용이. 다른 서비스에게 영향 x
	- 개발 속도 향상 

- 단점 : 
	- 복잡한 관리 : 서비스 많아지면 관리 복잡. 서비스 간 통신, 데이터 일관성 유지 어려움
	- 분산된 데이터 관리
	- 배포 복잡성 : 독립적으로 배포되므로 배포 파이프라인이 복잡

- 적용 예시 : 
	- 대규모 프로젝트
	- 빈번한 배포 필요
	- 다양한 기술 스택 필요
	- 분산 팀 협업
## 서버리스 아키텍처
- 서버 관리 없이 비즈니스 로직에만 집중하는 클라우드 컴퓨팅 모델
- Faas
- 구성 요소 : 
	- 함수 : 특정 이벤트에 의해 실행되는 코드 블록. 작은 단위로. . AWS Lambda, Azure Functions, Google Cloud Functions 등
	- 트리거 : 함수 실행 이벤트 유발 이벤트. HTTP 요청, 데이터베이스 변경, 파일 업로드, 타이머 등
	- API 게이트웨이 : 클라이언트 요청을 서버리스 함수로 라우팅하는 역할. AWS API Gateway 등
	- 데이터 저장소 : DB

- 장점 : 
	- 비용 효율성 : 사용한 만큼만 지불
	- 자동 확장 : 자동으로 리소스 확장, 축소
	- 쉬운 관리
	- 빠른 배포 : 함수 단위

	- 단점 : 
		- 실행 시간 제한 : 대부분의 서버리스 플랫폼은 최대 실행 시간을 제한
		- 상태 관리 어려움 : 상태 유지 x
		- 디버깅 및 모니터링 어려움

- 적용 사례
	- 이벤트 기반 애플리케이션
	- 빠른 프로토타입 및 MVP 개발
	- 마이크로서비스 아키텍처의 일부
	- 스케일 아웃이 중요한 작업
# 아키텍처 설계 과정
## 1. 요구사항 분석 : 요구사항 수집 및 문서화
### 기능적 요구사항
- 정의 : 시스템이 수행해야 하는 기능, 작업 정의
- 목표 : 수행하려는 동작 지원
### 비기능적 요구사항
- 정의 : 시스템 성능, 보안, 가용성 등 외적인 속성
- 목표 : 시스템 품질과 사용자 경험 개선
### 요구사항 수집 및 문서화
- 요구사항 수집
	- 이해관계자 인터뷰
	- 설문조사
	- 브레인스토밍

- 요구사항 문서화
	- 요구사항 명세서
	- 사용자 스토리
	- 기능 명세서
## 2. 요구사항 분석 : 시스템 모델링
### 유스케이스 다이어그램
- 목적 : 시스템과 사용자 상호작용 시각적으로 표현
- 구성 요소
	- 액터 : 시스템 외부에서 상호작용하는 사용자 또는 시스템
	- 유스케이스 : 사용자가 시스템을 통해 수행할 수 있는 기능이나 작업
	- 시스템 경계 : 유스케이스와 액터가 상호작용하는 시스템 범위 박스
### 클래스 다이어그램
- 목적 : 시스템 클래스 구조 정의, 관계 설명
- 구성 요소 :
	- 클래스
	- 속성
		- 요소
		- 메서드
	- 관계
### 시퀀스 다이어그램
- 객체 간의 메시지 흐름과 상호작용을 시간 순서로 표현
- 구성 요소 : 
	- 객체 : 시스템 구성 요소
	- 메시지
	- 타임라인
## 2. 요구사항 분석 : 데이터 흐름과 상호작용 모델링
### 데이터 흐름 다이어그램
- 목적 : 시스템 내에서 데이터가 어떻게 흐르고 처리되는지 표현
- 구성 요소 : 
	- 프로세스 : 데이터 처리
	- 데이터 흐름 : 데이터 이동 경로
	- 데이터 저장소
	- 외부 엔티티 : 시스템 외부에서 데이터 생성하거나 소비하는 주체
### 상호작용 다이어그램
- 목적 : 객체 간의 상호작용과 메시지 흐름을 상세히 모델링
- 구성 요소 : 
	- 객체
	- 메시지
	- 활동 : 상호작용 과정
## 3. 구조 설계 : 시스템 모듈 분할
- 시스템을 더 작은 단위(모듈)로 나누어 관리 및 역할과 책임을 명확히
- 방법
	- 기능적 분할 : 비슷한 기능 묶음
	- 계층적 분할 : 프레젠테이션, 비즈니스 로직, 데이터 액세스 등의 계층으로
	- 도메인 기반 분할 : 특정 도메인(사용자 관리, 주문 처리 등)에 따라
	  
- 활용
	- 요구사항 분석 결과 활용
	- 시스템 모델링 활용 : UML 다이어그램을 사용하여 모듈 간 관계와 인터페이스 정의
## 3. 구조 설계 : 컴포넌트 간 인터페이스 정의
- 목적 : 모듈 간 명확한 통신 규칙을 정의
- 방법 : 
	- API 설계 : 각 모듈이 외부에 노출하는 인터페이스 정의
	- 계약 기반 개발 : 모듈 입, 출력 동작 정의
	- 데이터 형식 정의

- 활용 : 
	- 요구사항 분석 결과 활용
	- 시스템 모델링 활용 : 시퀀스 다이어그램 사용하여 인터페이스 설계
## 4. 아키텍처 선택 : 요구사항에 따른 적합한 아키텍처 선택
- 적합한 아키텍쳐 패턴 선택
- 방법 : 
	- 요구사항 분석 - 근데 보통 여기서 아키텍처 대충 정해짐
	- 모듈 구조 분석
	- 패턴 특성 비교
	- 기술적 고려 사항

- 활용 : 
	- 요구사항 분석 결과 활용
	- 시스템 모델링 활용

# 시스템 설계 원칙
- 모듈화
	- 시스템을 독립적인 기능 단위로 나누어 설계하는 접근법
	- 장점 : 
		- 모듈 단위로 독립적으로 수정 및 업데이트 가능 
		- 병렬 작업과 팀 간 협업 용이 
		- 각 모듈을 독립적으로 테스트 가능
		
- 재사용성 
	- 기존에 개발한 모듈이나 컴포넌트를 새로운 시스템에서 반복적을 사용하는 것
	- 장점 : 
		- 검증된 모듈을 활용하여 개발 속도 향상 
		- 동일한 기능을 다양한 시스템에서 제공 
		- 중복된 개발 작업을 줄여 비용 절감
		  
- 결합도
	- 모듈(클래스, 객체 등등) 간 의존성의 정도
	- 낮아지는 방향으로 설계
	- 목표: 낮은 결합도 
		- 모듈 간 독립성을 보장하고 변경 시 영향 최소화 
		- 명확한 인터페이스 정의와 최소한의 데이터 공유

- 응집도
	- 모듈 내 구성 요소들이 밀접하게 관련되어 있는 정도
	- 목표: 높은 응집도 
		- 모듈이 단일 기능에 집중하고 명확한 책임 부여 
		- 모듈이 하나의 역할이나 기능을 수행하도록 설계

- 확장성
	- 시스템이 데이터, 트래픽, 기능 요구 증가에 대응하는 능력
	- 유형 : 
		- 수평 확장 : 서버나 인스턴스 추가
		- 수직 확장 : 기존 서버 성능 업그레이드
	- 방법 : 
		- 모듈화
		- 분산 처리

- 유연성
	- 시스템이 변화하는 요구사항에 적응하는 능력
	- 특징 : 
		- 구성 요소 교체 용이
		- 기술적 적응
	- 방법 : 
		- 추상화
		- 플러그인 아키텍처
# DevOps와 CI/CD
## DevOps
- DevOps는 'Development'와 'Operations'의 합성어로, 소프트웨어 개발과 IT 운영을 통합하는 문화와 실천 방식을 의미
  
- DevOps 주요 원칙 
	- 협업: 개발팀과 운영팀 간의 긴밀한 협력 
	- 자동화: 반복적인 작업의 자동화를 통한 효율성 증대 
	- 지속적 개선: 피드백 루프를 통한 지속적인 프로세스 개선 
	- 고객 중심: 최종 사용자의 요구사항에 빠르게 대응 
	- 빠른 배포: 작은 단위의 변경사항을 자주 배포
	  
- 도구와 기술
	- 버전 관리: Git, GitHub, GitLab 
	- CI/CD: Jenkins, GitLab CI, CircleCI 
	- 컨테이너화: Docker, Kubernetes • 구성 관리: Ansible, Puppet, Chef 
	- 모니터링: Prometheus, Grafana, ELK Stack 
	- 클라우드 플랫폼: AWS, Azure, Google Cloud Platform
## CI/CD
- CI : 새로운 코드 변경 사항이 정기적으로 빌드 및 테스트 되어 공유 레포지토리에 통합
- CD : 자동으로 스테이징 환경이나 배포 환경에 배포

- CI/CD 파이프라인
	- 코드 변경사항을 지속적으로 통합(CI)하고, 이를 자동으로 테스트하여 배포 (CD)하는 일련의 단계
		1. 코드 커밋: 개발자가 코드를 버전 관리 시스템에 커밋합니다. 
		2. 빌드: 코드를 컴파일하고 실행 가능한 형태로 만듭니다. 
		3. 테스트: 단위 테스트, 통합 테스트 등을 실행합니다. 
		4. 정적 코드 분석: 코드 품질과 보안 취약점을 검사합니다. 
		5. 스테이징 환경 배포: 운영 환경과 유사한 환경에 배포합니다. 
		6. 통합 테스트: 전체 시스템 레벨의 테스트를 수행합니다. 
		7. 운영 환경 배포: 최종적으로 실제 운영 환경에 배포합니다. 
		8. 모니터링: 배포 후 시스템 성능과 오류를 모니터링합니다.

- 자동화의 중요성
	- 자동화는 개발자가 코드 작성과 기능 개선에 집중
