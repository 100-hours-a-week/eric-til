# Promise

- 비동기 처리에 사용되는 객체
- 콜백 + 비동기
- 생산자-소비자 패턴

- Promise 체인
    - 프로미스 패턴 중 하나
    - 비동기 프로미스 작업을 순차적으로 실행하기 위해
    - then 메소드는 항상 프로미스가 반환되는데 반환된 프로미스는 then 메서드를 가짐.
    
    ```java
    fetchData()
      .then((data) => parseData(data))
      .then((parsed) => filterData(parsed))
      .then((filtered) => sortData(filtered))
      .then((sorted) => {
        // 최종 결과 처리
        console.log('최종 결과 처리: ', sorted);
      })
      .catch((error) => {
        // 에러 처리
        console.error(error);
      });
    ```
    

- Promise의 상태
    - 대기 : 프로미스가 생성되어 비동기 처리가 아직 완료되지 않은 상태
    - 성공 : 비동기 처리가 성공적으로 완료되어 결과 값을 반환한 상태. `resolve`
    - 실패 : 비동기 처리 중 오류 발생하여 에러 원인 반환한 상태. `reject`

- Promise.all() 사용법
    - 병렬적인 비동기 작업을 처리하기 위해 사용함
    - 배열에 담아서 전달하고 모두 성공이어야 성공 상태, 하나라도 실패하면 에러
    - UI 최적화
    
    ```java
    Promise.all([promise1, promise2, promise3])
        .then(results => {
            console.log('All data received:', results); // 모든 데이터가 로드된 후 결과를 출력합니다.
        })
        .catch(error => {
            console.error('Failed to fetch data:', error); // 하나라도 실패하면 오류를 출력합니다.
        });
    ```
    

---

# Async / Await

- 정의 :
    - Async : 비동기 처리를 위해 항상 프로미스 반환하는 함수 선언 키워드
    - Await : 프로미스 완료될때 까지 비동기 함수 실행 임시 중단하고 결과 반환
- Async는 반환 값이 프로미스가 아니면 프로미스로 wrapping해서 반환함

- 비동기 처리를 동기 코드처럼 읽기 쉽게 작성할 수 있도록 도와주는 기능
- 사용 이유 :
    - Async : 비동기 작업을 동기적인 흐름으로 작성하기 위해서
    - Await : 블로킹하지 않으면서 비동기 결과를 동기 코드처럼 처리하기 위해서
- 사용 방법 :
    - Async : 함수 앞에 붙여서 사용
    - Await : async 함수 내에서 Promise 앞에 await 붙임
    
    ```java
    function delayAsync() {
        return new Promise(resolve => setTimeout(() => {
            console.log("2. 작업 완료");
            resolve();
        }, 2000)); // 2초 후 완료
    }
    
    async function execute() {
        console.log("1. 작업 시작");
        await delayAsync();  // 여기서만 기다리고, 전체 프로그램은 멈추지 않음
        console.log("3. 다음 작업 실행");
    }
    ```
    
- 예외 처리 방식 :
    - try-catch 문법 사용
    
    ```java
    // 비동기 함수를 사용하여 사용자 정보를 가져오고 출력하는 함수
    async function fetchAndDisplayUser(id) {
      try {
        const result = await getUserNameById(id);
        if (result.success) {
          console.log(result.user); // 사용자 정보 출력
        }
      } catch (error) {
        console.log(error.message); // 에러 처리
      }
    }
    ```
    

# 자바스크립트 인터프리터

- 고수준의 프로그래밍 언어 소스코드를 한 줄씩 즉시 실행하는 프로그램

| **특성** | **설명** |
| --- | --- |
| **즉시 실행** | 코드를 수정하고 바로 결과를 볼 수 있어 개발 생산성을 향상시킵니다. |
| **플랫폼 독립성** | 인터프리터 설계가 운영 체제에 크게 구애받지 않아 다양한 시스템에서 실행될 수 있습니다. |
| **실행 속도** | 코드를 한 줄씩 읽고 해석하는 과정 때문에 컴파일 언어보다 실행 속도가 느립니다. |
| **리소스 사용** | 실시간 해석 과정 때문에 실행 시 컴파일 언어보다 더 많은 리소스를 사용할 수 있습니다. |

# 자바스크립트 엔진

- 정의 : JavaScript 코드를 실행하는 프로그램. 브라우저나 Node.js 환경에서 JavaScript를 기계어(machine code)로 변환하여 실행

- V8 엔진 동작 과정 :
    1. 생성과 컴파일 단계 : 읽어 들여 준비하는 과정. 사전 파싱
    1. 소스 코드 읽기 (토큰화) : 코드는 의미 있는 조각으로 나누는 과정
    
        
         2. 구문 분석 (AST 생성) : 토큰을 바탕으로 코드 구조를 트리 형태로 변환하여 추상 구문 트리 생성
        
         3. 실행 컨텍스트 생성 : 각 실행 컨텍스트는 호출되는 함수에 대한 정보와 환경을 관리하며, 스택 구조에서 관리
        
         4. 렉시컬 환경 및 렉시컬 스코프 결정 : 렉시컬 환경은 현재 범위에서 접근 가능한 변수랑 함수 정보를 담고 있는 환경 맵을 말함. 렉시컬 스코프는 코드의 구조나 접근 범위를 미리 정해놓는 역할을 한다. 함수는 호출된 위치가 아닌 선언된 위치에 따라 스코프가 고정됨.
        
         5. 호이스팅 : 변수와 함수를 읽고 스코프 최상단에 위치시키는 과정
            var 의 경우 선언이 호이스팅 되어 최상단에서 undefined 로 초기화 실제 값으로 할당은 원
            래 코드 위치에서 진행
            const, let을 사용한 변수는 Temporal Dead Zone(TDZ)에 들어가서 선언 위치 전에는 접근
            할 수 없음
        
    2. 실행 단계 : 생성, 컴파일 단계에서 설정된 구조 바탕으로 실행
        1. 바이트 코드 생성 : 트리 구조 기반으로 낮은 수준의 언어로 변환
        
        2. 변수 할당과 실행 : 인터프리터와 컴파일러가 변수 할당하고 함수 실행
        
        3. 스코프 체인 : 변수 접근에 사용되는 주요 메커니즘. 현재 스코프에서 시작하여 상위 스코프로 이동하면서 변수나 함수를 찾음.

- JIT 컴파일러 역할
    - JIT 컴파일러 :
        - JIT 컴파일러는 처음에 소스코드를 파싱하여 `중간언어(IR)`인 `바이트 코드` 형태로 먼저 변환. 이 후 `인터프리터` 모드라면 `바이트 코드`를 하나씩 읽어가며 동작을 수행하고, `JIT 모드`라면 생성된 `바이트 코드`를 기반으로 `네이티브 코드`로 `컴파일` 하여 수행함.
    - V8은 AJITC 즉 적응형 JTI 컴파일러임. JITC와는 다르게 모든 바이트코드를 네이티브 코드로 컴파일 하지 않음. 다만 프로파일링을 통해 최적화 할 코드(Hot code)를 선별한 후 해당 코드들만 컴파일함
    - 핫 코드를 감지하여 네이티브 코드로 변환해 성능을 개선

---

# 렉시컬 스코프

- 스코프 ? 변수, 함수 등이 어디서 접근할 수 있는지를 결정하는 범위
- 정의 : 함수가 선언된 위치(렉시컬 환경)을 기준으로 스코프를 결정하는 것.
- 실행 시점에 관계없이, 코드가 작성된 위치에 따라 변수 접근이 결정됨.

---

# 스코프 체인

- 변수를 찾을 때 현재 스코프에서 찾고 없을 경우, 상위 스코프를 따라 올라가는 구조
- 변수를 찾을 때 현재 스코프 → 부모 스코프 → 전역 스코프 순서로 검색
- 최상위 스코프(전역 스코프)까지 올라가도 변수가 없으면 `ReferenceError` 발생
자
- 자바스크립트의 실행 컨텍스트에 의해 관리됨
    1. 함수가 실행되면 실행 컨텍스트가 생성됨
    2. 해당 컨텍스트에는 현재 스코프 + 상위 스코프에 대한 참조가 저장됨
    3. 변수를 찾을 때 현재 스코프에서 찾고, 없으면 상위 스코프를 따라 탐색

- `var`는 호이스팅되지만 `let`, `const`는 TDZ(일시적 사각지대) 때문에 선언 전 접근 시 에러 발생

---

# 질문

## 1. Promise란 무엇이고, 콜백과 비교했을 때의 장점은?

### Promise란?

Promise는 비동기 작업의 완료(혹은 실패)를 나타내는 객체로, 미래의 값을 다룰 수 있게 해준다.

즉, 현재는 없지만 나중에(비동기 작업이 끝났을 때) 가질 값을 나타내며, 콜백 기반의 비동기 처리보다 더 구조적이고 직관적으로 관리 가능하다.

### 콜백과의 비교 및 Promise의 장점

전통적으로 비동기 작업은 콜백 함수를 사용하여 처리되었지만, 다음과 같은 문제점이 있었다:

1. 콜백 헬(Callback Hell)
    - 비동기 작업이 중첩될 때, 콜백 함수가 계속 내부로 중첩되면서 코드가 복잡하고 읽기 어려워짐.
    - 가독성이 떨어지고, 디버깅이 어렵다.
2. 에러 핸들링의 어려움
    - 여러 개의 콜백 함수가 중첩될 경우, 어디서 에러가 발생했는지 찾기 힘들고, 예외 처리가 어렵다.

Promise를 사용하면

- `.then()` 체이닝을 통해 비동기 로직을 순차적으로 읽기 쉽게 작성할 수 있음.
- `.catch()`를 활용하여 에러를 일괄적으로 처리 가능.
- `Promise.all()` 같은 메서드를 사용하면 여러 개의 비동기 작업을 효율적으로 병렬 실행 가능.

---

## 2. Promise의 세 가지 상태

1. Pending (대기)
    - 초기 상태로, 비동기 작업이 아직 완료되지 않음.
2. Fulfilled (이행)
    - 비동기 작업이 성공적으로 완료되었으며, `resolve()`를 통해 결과 값을 반환.
3. Rejected (거부)
    - 비동기 작업이 실패했으며, `reject()`를 통해 오류 정보를 반환.

Promise는 한 번 Fulfilled 또는 Rejected 상태가 되면 다시 변경되지 않는다는 것이 중요한 특징이다.

---

## 3. then(), catch(), finally()의 차이와 사용 사례

1. then()
    - 성공한 경우(`resolve() 호출된 경우`) 실행된다.
    - 여러 개의 `.then()`을 체이닝하여 순차적으로 비동기 작업을 실행할 수 있음.
2. catch()
    - 실패한 경우(`reject() 호출된 경우`) 실행된다.
    - `.then()` 체이닝 중간에서 발생한 오류도 잡아서 처리할 수 있음.
3. finally()
    - 성공 여부와 관계없이 항상 실행된다.
    - 자원 해제, 로딩 스피너 제거 등의 용도로 사용됨.

---

## 4. Promise Chain 개념과 장점

### Promise Chain이란?

`then()`을 연속적으로 사용하여 순차적으로 비동기 작업을 실행하는 방식.

즉, 이전 작업의 결과를 다음 `then()`으로 전달하며 계속 이어지는 구조.

### 장점

- 코드 가독성이 좋음 → 콜백 중첩보다 읽기 쉬움
- 에러 핸들링이 쉬움 → `.catch()` 하나로 모든 에러 처리 가능
- 비동기 작업의 순차적 실행이 자연스러움 → 동기 코드처럼 이해하기 쉬움

---

## 5. Promise.all()과 Promise.allSettled()의 차이점

1. Promise.all()
    - 여러 개의 Promise를 병렬 실행하며, 모두 성공해야만 결과를 반환.
    - 하나라도 실패하면 전체가 실패(`reject`) 상태가 됨.
    - 실패 시 다른 Promise의 결과를 알 수 없음.
2. Promise.allSettled()
    - 여러 개의 Promise를 병렬 실행하지만, 각각의 결과를 개별적으로 반환.
    - 실패한 Promise가 있어도 나머지는 정상적으로 처리됨.
    - 실패한 경우에도 `"status": "rejected"`와 같은 형태로 반환됨.

---

## 6. Async 메서드가 항상 Promise를 반환하는 이유

Async 함수는 내부적으로 비동기 처리를 Promise로 감싸기 때문이다.

- `await` 키워드를 만나면 해당 비동기 작업이 끝날 때까지 기다린 후 Promise의 결과를 반환.
- 하지만 `await` 없이도, Async 함수 자체는 자동으로 Promise를 반환한다.

이러한 동작을 통해 비동기 코드를 동기적인 코드처럼 작성하면서도 Promise 기반의 비동기 처리를 유지할 수 있다.

---

## 7. Async/Await가 동기 코드처럼 보이지만 실제로는 비동기/논블로킹 방식으로 동작하는 이유

Async/Await는 내부적으로 Promise 기반의 비동기 처리 방식을 사용하지만,

- `await`을 만나면 해당 비동기 작업이 완료될 때까지 기다린 후 다음 코드로 진행
- 하지만 기다리는 동안 이벤트 루프는 다른 작업을 수행하므로 블로킹이 발생하지 않음.

즉, 코드는 동기처럼 보이지만, 백그라운드에서는 비동기적으로 실행된다.

---

## 8. V8 엔진의 JIT 컴파일러가 성능에 미치는 영향

V8 엔진은 자바스크립트를 인터프리터가 아니라 JIT(Just-In-Time) 컴파일 방식으로 실행한다.

이 방식의 장점은:

- 자주 실행되는 코드(핫 코드)를 최적화하여 실행 속도를 향상
- 코드 실행 중에 성능 최적화를 적용하여 더 빠르게 동작
- 인터프리팅보다 빠르면서도 컴파일된 언어(C, C++)에 비해 빠르게 실행 가능

---

## 9. 자바스크립트 코드 실행 과정에서 호이스팅이 발생하는 시점과 이유

호이스팅은 자바스크립트가 실행 컨텍스트를 생성할 때 발생한다.

- 실행 전, 변수 및 함수 선언이 메모리에 먼저 할당됨.
- `var` 선언과 함수 선언문(`function`)은 코드 최상단으로 끌어올려짐(호이스팅됨).
- 하지만 `let`, `const`는 호이스팅되지만 TDZ(Temporal Dead Zone)로 인해 초기화 전 접근이 불가능.

---

## 10. 렉시컬 스코프와 실행 컨텍스트의 관계

렉시컬 스코프는 함수가 선언된 위치를 기준으로 스코프가 결정된다.

실행 컨텍스트는 각 함수 실행 시 생성되며, 변수 환경(스코프 체인)과 함께 관리된다.

즉, 렉시컬 스코프 덕분에 실행 컨텍스트가 함수 선언 시점을 기준으로 스코프를 결정할 수 있다.

---

## 11. 자바스크립트 엔진에서 스택과 힙의 역할 및 차이점

1. 스택(Stack)
    - 함수 실행 컨텍스트(호출 스택) 저장
    - 함수 실행이 끝나면 자동으로 제거됨 (LIFO 구조)
2. 힙(Heap)
    - 객체 및 동적 메모리 할당을 관리
    - 크기가 큰 데이터를 저장하며, 필요하지 않으면 가비지 컬렉션에 의해 제거됨.

---

## 12. 자바스크립트의 스코프 체인이 변수 검색에 미치는 영향

스코프 체인은 변수를 찾을 때 현재 스코프에서 부모 스코프를 거쳐 전역 스코프까지 검색하는 방식이다.

- 함수 내부에서 변수를 찾지 못하면 외부 스코프를 따라 올라가며 검색
- 최상위 스코프(전역 스코프)까지 가도 없으면 `ReferenceError` 발생

이 구조 덕분에 변수 검색이 체계적으로 이루어지고, 클로저 같은 기능이 가능하다.
