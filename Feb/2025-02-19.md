# 객체

- 정의 : 속성과 기능을 가진 독립적인 데이터 단위
- 자바 스크립트에서 객체는 원시 타입(숫자, 문자열, 불리언, null, undefiend, Symbol)을 제외한 나머지 값
- key, value로 구성된 속성의 집합. 하나의 container라고 할 수 있음
- 사용 이유 : 데이터와 관련 연산을 묶어 관리하기 위해
    - 재사용성 증가
    - 모듈화
    - 추상화
- 사용 방법 : key-value 쌍을 이용해 데이터 저장. 점, 대괄호 표기법으로 접근, 수정.
    - 객체 리터럴 사용
        - {}로 객체 생성, 속성과 메소드 정의
        - 속성 : 객체 속한 값
        - 메소드 : 객체의 기능과 동작
        - 코드 중복 가능성
    - 생성자 함수
        - new 키워드 사용
        - 객체를 여러번 생성할 때 유용
        - 문법적으로 복잡
        - 클래스 사용
            - 생성자보다 객체지향적인 요즘 방법
            - class 키워드 사용 정의 이후 new 키워드로 생성
            ![[Pasted image 20250219094530.png]]
- 객체 내에서 메서드 표현
    - 객체 내부에서 사용하는 함수는 메소드로 부름
    - 리터럴 생성시 선언(default)
        - `myMethod: function() {}`
    - 축약 메서드 표현번
        - `myMethod() {}`
    - 메소드 동적 추가
        - 메소드를 동적으로 추가할 수 있음
        - `myObject.anotherMethod = function() {}`
- getter/setter, Private 변수
    - 외부 스코프에서 내부 스코프 변수에 접근 못하게

```
const person = new Person('John'); //
private 변수를 직접 변경했을 경우 반영되지 않음
person.name = 'Park'; // John
console.log(person.getName());
person.setName('Jane'); // Jane
console.log(person.getName());
```

---

# 네임스페이스

- 정의 : 변수, 함수, 클래스 등의 식별자가 충돌하지 않도록 그룹화하는 방법
- 사용 이유 :
    - 변수명 충돌 방지
    - 코드 구조화
    - 가독성 및 유지보수성 향상

---

# 프로그래밍 패러다임

- 정의 : 프로그램 만드는데 사용되는 기본적 접근 방식
- 사용 이유 : 체계적, 재사용성, 효율성
- 사용 방법 : 문제와 특성에 맞게 적합한 페러다임 선택해 구조화
    - 절차 지향 프로그래밍 :
        - 명령어의 연속적인 실행
        - 명령어의 순서에 따라 데이터 조작, 실행
    - 객체 지향 프로그래밍 :
        - 객체 간의 상호작용으로 실행되는 프로그램
        - 데이터와 메소드를 묶어 객체로 만듦
    - 함수형 프로그래밍 :
        - 함수를 일급 객체 취급, 상태와 가변 데이터 피함.
        - 일급 객체 : 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체

---

# 함수

- 정의 : 재활용하기 위해 묶어놓은 코드들의 집합
- 사용 이유 : 재사용성
- 사용 방법 : 특정 작업 수행 코드 블럭을 함수로 정의하고, 필요할 때 호출
    - 자바 스크립트에서 함수 사용하는 방법
        - 함수 선언문
            - function 키워드를 사용하여 정의
            - 호이스팅(함수 전체를 스코프 최상단으로)으로 인해 어느 위치에서든 함수를 호출할 수 있음.
            - `function greet(name) {}`
        - 함수 표현식
            - 함수를 변수에 할당하는 방식으로 정의
            - 변수에 할당되기 전에는 사용 불가
            - `const greet = function(name) {}`
        - 화살표 함수
            - function 키워드 없이 => 기호로 표현
            - 자신만의 this 없어서 외부 스코프 this를 그대로 사용
            - `const greet = (name) =>` Hello, ${name}`;`
- 함수 정의 방식
    - 인자 전달
        - 인자들은 기본 자료형이나 객체, 배열 등 어떤 타입의 값 가능
        - `function sum(a, b) {}`
    - 객체 전달
        - `function sum(obj) { return obj.number1 + obj.number2; }`
    - 객체 반환
        - 여러 값 반환해야 할 때 객체 내에서 필요한 데이터 그룹화
        - `const { name, age, height, ...rest } = getUserInfo();`
        - 구조 분해 할당을 사용한 객체 반환 처리`
    - 배열 반환
        - 마찬가지로
        - `const [number1, number2, ...rest] = getNumbers();`
        - 구조 분해 할당을 사용한 배열 반환 처리
    - 구조 분해 할당
        - 배열이나 객체 속성을 분해하여 그 값을 개별 변수에 담을 수 있게 하는 자바 스크리트 표현식

---

# 순수 함수

- 정의 : 주어진 입력이 동일하면 리턴 값이 항상 같은 함수
- 특징 :
    - 일관된 결과
    - 부수 효과 없음
    - 명확한 구성 요소
    - 부수 효과 : 함수가 실행될 때 함수 외부의 상태를 변경하거나 외부 상태에 의존하여 결과를 산출하는 것을 의미
        - 문제점
            - 디버깅 어려움 : 외부 상태 변화 추적하기 힘듬
            - 코드 재사용성 저하 : 외부 변수에 의존하면 재사용하기 어려움
            - 병렬 처리의 제한 : 스레드-세이프 하지 않아 병렬 처리 시 문제 가능
            - 유지 보수 복잡성
- 사용 이유 :
    - 결정적 동작 : 시스템이 명확하고 예측 가능한 결과를 냄. 결과값 보장
    - 부수 효과 없는 동작
- 사용 방법 :
    - 외부 상태에 의존하지 않고, 주어진 입력에 대해 항상 동일한 출력을 반환하는 함수를 정의하여 사용

---

# 일급 함수

- 정의 : 함수를 일급 시민으로 취급하여, 다른 변수처럼 사용할 수 있게 하는 특성 가진 함수
    - 일급 시민 : 프로그래밍 언어 내에서 모든 연산과 기능을 자유롭게 사용할 수 있는 권리
- 사용 이유
    - 코드의 재사용성 향상 : 함수를 변수에 저장하거나 다른 함수로 전달
    - 고차 함수 : 함수를 파라미터로 넘기거나 반환
    - 유연한 함수 처리 : 함수를 데이터 구조에 저장하고 필요할 때 사용
    - 추상화와 캡술화 용이 : 세부 구현 숨기고 외부에서 접근 못하게
- 사용 방법
    - 함수를 변수에 할당
        - 함수를 일반 변수에 할당하여 값처럼 다루기
    - 함수를 다른 함수의 인자로 전달
    - 함수에서 다른 함수를 반환
    - 고차함수를 사용한 간단한 조합

```
function multiplyBy(multiplier) {
	return function(number) {
		return number * multiplier;
	};
}

const double = multiplyBy(2);
console.log(double(5)); // 10 출력

```

---

# 익명 함수

- 정의 : 재활용하기 위해 묶어놓은 이름 없는 함수. 일반적으로 변수에 할당되거나 다른 함수의 인자로 직접 전달될 때 사용
- 사용 이유 :
    - 코드 간결성
    - 임시 함수의 사용 : 특정 함수가 한 번만 사용될 때
    - 클로저 생성
    - 이벤트 핸들러와 콜백 : 일회성으로 사용되는 경우가 많아서
- 사용 방법 :
    - 함수 표현식
        - `const greet = function() { console.log("Hello, world!"); };`
    - 다른 함수의 인자로 전달

```
// 함수를 인자로 받아 호출하는 함수
function executeFunction(callback) {
    callback();
}

// 익명함수를 변수 greet에 할당
const greet = function() {
    console.log("Hello, world!");
};

// 함수 인자로 전달하여 실행
executeFunction(greet);  // 출력: "Hello, world!"

executeFunction(function()) {
	console.log("Hello, World");
} // 이렇게도 가능

```

---

# 즉시 실행 함수

- 정의 : 정의되자마자 실행되는 함수
- 사용 이유 :
    - 변수와 함수의 스코프 제한 : 즉시 실행 함수 내부에서 선언된 변수와 함수는 외부에서 접근할 수 없음. 변수 이름 충돌 방지
    - 즉시 실행 : 초기화 로직이나 웹 페이지 로드 시 즉시 수행해야 할 때
    - 코드의 캡술화 관리 : 불필요한 전역 변수 관리, 코드 그룹화
- 사용 방법 :
    - 함수를 ()로 감싸서 선언
    - `(function() { // 여기에 코드를 작성합니다. })();`
    - 익명 함수 표현식 / 기능 코드 / 호출 연산자(= ( ); )

---

# 모듈

- 정의 : 재사용 가능한 코드 조각
- 함수는 도구, 모듈은 도구 상자
- 사용 이유 : 복잡한 프로그램을 작은 부분으로 나누어 재사용과 유지보수 용이
- 사용 방법 : 필요한 기능 별로 분리해 파일 단위로 작성
    - CJS (CommonJS) = module.exports
        - 동기적으로 동작
        - 백엔드 개발
            - Node.js를 활용한 SSR 개발시 사용
            - 기존 node.js 프로젝트를 사용하거나 라이브러리를 사용해야 하는 경우
    - ESM (ECMAScript Modules) = export
        - 프론트엔드 영역에서 표준화 되어 널리 쓰이는 방식
        - node.js 12버전 부터 ESM을 공식 채택 했으나 CJS 방식을 주로 사용
            - 최신 웹 개발 환경
            - 최적화가 필요한 환경 (Tree-shaking, Code Splitting, Dynamic Imports - Lazy Loading)
            - FE - BE 스텍을 맞추고 싶은 경우
    - Named Export / import
        - 여러 값을 내보낼 때 각각의 고유한 이름으로 내보냄
    - Default Export / import
        - 모듈 당 하나의 값을 내보낼 때 사용
        - 모듈 전체가 하나의 클래스나 객체일 때

---

# 콜백 함수

- 정의 : 다른 함수에 인자로 전달되어 그 함수의 내부에서 실행되는 함수
    - 동기적 콜백과 비동기적 콜백으로 나누어짐
        - callback != 비동기 함수
    - 동기적 콜백은 즉시 실행됨
    - 비동기적은 이벤트나 시간 이후 실행됨
- 사용 이유 :
    - 동기 코드의 한계
    - 블로킹 동작 한계
- 사용 방법 :
    - 일급 함수의 개념으로부터 비롯됨
    - 배열 매서드와 콜백 함수
    - 함수를 반환하는 함수
    - 함수 컴포지션

---

# 비동기 - 프로미스

- 비동기/논블로킹 코드 결과 처리를 하는 방법

```
const promise =  new Promise((resolve, reject) => {
		const isSuccess = true;

		if(isSuccess){
				resolve('작업 성공');
		} else {
				reject('작업 실패')
		}
})

```

- 생산자 - 소비자 패턴 ( Producer - Customer Pattern )
    - 생성자 역할: `new Promise((resolve, reject) => {...})`는 비동기적으로 데이터 로드 작업을 생산
    - 소비자 역할: 생성된 프로미스 객체의 결과(성공 또는 실패)는 `.then()`, `.catch()`, `.finally()` 메서드를 통해 소비
- Promise 상태
    - 대기 : 프로미스가 생성되어 비동기 처리가 아직 완료되지 않은 상태
    - 성공 : 비동기 처리가 성공적으로 완료되어 결과 값을 반환한 상태
    - 실패 : 비동기 처리 중 오류 발생하여 에러 원인 반환한 상태
- Promise 생성
    - new 생성자로 생성
    - 생성자는 resolve, reject를 파라미터로 받음
- Promise 사용
    - then : 프로미스 성공적으로 이행 됐을 때 실행될 콜백 함수 등록
    - catch : reject 되었을 때 실행될 콜백 함수 등록. 하나의 catch에서 일괄 처리 가능
    - finally : 성공/실패 관계없이 마지막에 항상 실행되는 콜백
